

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>velocyto.analysis &mdash; velocyto 0.9.5 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="velocyto 0.9.5 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> velocyto
          

          
          </a>

          
            
            
              <div class="version">
                0.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Welcome to velocyto.py!</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install/index.html">Installation Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial/index.html">Tutorial</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../fullapi/index.html">API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/index.html">Notebooks</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../citing/index.html">Authors and citations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../license/index.html">License</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">velocyto</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>velocyto.analysis</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for velocyto.analysis</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="k">import</span> <span class="n">pdist</span><span class="p">,</span> <span class="n">squareform</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">norm</span> <span class="k">as</span> <span class="n">normal</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">sparse</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="k">import</span> <span class="n">SVR</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="k">import</span> <span class="n">PCA</span>
<span class="kn">from</span> <span class="nn">sklearn.manifold</span> <span class="k">import</span> <span class="n">TSNE</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="k">import</span> <span class="n">NearestNeighbors</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="k">import</span> <span class="n">jit</span>
<span class="kn">import</span> <span class="nn">loompy</span>
<span class="kn">from</span> <span class="nn">.neighbors</span> <span class="k">import</span> <span class="n">knn_distance_matrix</span><span class="p">,</span> <span class="n">connectivity_to_weights</span><span class="p">,</span> <span class="n">convolve_by_sparse_weights</span><span class="p">,</span> <span class="n">BalancedKNN</span>
<span class="kn">from</span> <span class="nn">.estimation</span> <span class="k">import</span> <span class="n">fit_slope</span><span class="p">,</span> <span class="n">fit_slope_offset</span><span class="p">,</span> <span class="n">fit_slope_weighted</span><span class="p">,</span> <span class="n">fit_slope_weighted_offset</span>
<span class="kn">from</span> <span class="nn">.estimation</span> <span class="k">import</span> <span class="n">clusters_stats</span>
<span class="kn">from</span> <span class="nn">.estimation</span> <span class="k">import</span> <span class="n">colDeltaCor</span><span class="p">,</span> <span class="n">colDeltaCorLog10</span><span class="p">,</span> <span class="n">colDeltaCorpartial</span><span class="p">,</span> <span class="n">colDeltaCorSqrtpartial</span><span class="p">,</span> <span class="n">colDeltaCorLog10partial</span>
<span class="kn">from</span> <span class="nn">.diffusion</span> <span class="k">import</span> <span class="n">Diffusion</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="o">*</span>


<div class="viewcode-block" id="VelocytoLoom"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom">[docs]</a><span class="k">class</span> <span class="nc">VelocytoLoom</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A convenient object to store the data of a velocyto loom file.</span>

<span class="sd">    Data will be stored in memory</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    A quick RNA velocity analysis can be performed as following</span>
<span class="sd">    &gt;&gt;&gt; import velocyto as vcy</span>
<span class="sd">    &gt;&gt;&gt; vlm = vcy.VelocytoLoom(&quot;foo.loom&quot;)</span>
<span class="sd">    &gt;&gt;&gt; vlm.normalize(&quot;S&quot;, size=True, log=True)</span>
<span class="sd">    &gt;&gt;&gt; vlm.default_filter_and_norm()</span>
<span class="sd">    &gt;&gt;&gt; vlm.default_fit_preparation()</span>
<span class="sd">    &gt;&gt;&gt; vlm.fit_gammas()</span>
<span class="sd">    &gt;&gt;&gt; vlm.predict_U()</span>
<span class="sd">    &gt;&gt;&gt; vlm.calculate_velocity()</span>
<span class="sd">    &gt;&gt;&gt; vlm.calculate_shift(assumption=&quot;constant_velocity&quot;)</span>
<span class="sd">    &gt;&gt;&gt; vlm.extrapolate_cell_at_t(delta_t=1)</span>
<span class="sd">    &gt;&gt;&gt; vlm.perform_TSNE()</span>
<span class="sd">    &gt;&gt;&gt; vlm.estimate_transition_prob(hidim=&quot;Sx_sz&quot;, embed=&quot;ts&quot;)</span>
<span class="sd">    &gt;&gt;&gt; vlm.calculate_embedding_shift(sigma_corr = 0.05)</span>
<span class="sd">    &gt;&gt;&gt; vlm.calculate_grid_arrows(smooth=0.8, steps=(40, 40), n_neighbors=300)</span>
<span class="sd">    &gt;&gt;&gt; vlm.plot_grid_arrows(scatter_kwargs_dict={&quot;alpha&quot;:0.35, &quot;lw&quot;:0.35, &quot;edgecolor&quot;:&quot;0.4&quot;, &quot;s&quot;:38, &quot;rasterized&quot;:True}, min_mass=24, angles=&#39;xy&#39;, scale_units=&#39;xy&#39;,</span>
<span class="sd">                             headaxislength=2.75, headlength=5, headwidth=4.8, quiver_scale=0.47)</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    S: np.ndarray</span>
<span class="sd">        Expressed spliced molecules</span>
<span class="sd">    U: np.ndarray</span>
<span class="sd">        Unspliced molecule count</span>
<span class="sd">    A: np.ndarray</span>
<span class="sd">        Ambiguous molecule count</span>
<span class="sd">    ca: dict</span>
<span class="sd">        Column attributes of the loom file</span>
<span class="sd">    ra: dict</span>
<span class="sd">        Row attributes of the loom file</span>
<span class="sd">    loom_filepath: str</span>
<span class="sd">        The original path the loom files has been read from</span>
<span class="sd">    initial_cell_size: int</span>
<span class="sd">        The sum of spliced molecules</span>
<span class="sd">    initial_Ucell_size: int</span>
<span class="sd">        The sum of unspliced molecules</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loom_filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loom_filepath</span> <span class="o">=</span> <span class="n">loom_filepath</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">loompy</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loom_filepath</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">layer</span><span class="p">[</span><span class="s2">&quot;spliced&quot;</span><span class="p">][:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">layer</span><span class="p">[</span><span class="s2">&quot;unspliced&quot;</span><span class="p">][:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">layer</span><span class="p">[</span><span class="s2">&quot;ambiguous&quot;</span><span class="p">][:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ca</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">col_attrs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ra</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">row_attrs</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initial_cell_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_Ucell_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ca</span><span class="p">[</span><span class="s2">&quot;_Valid&quot;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;fraction of _Valid cells is {np.mean(self.ca[&#39;_Valid&#39;])} but all will be taken in consideration&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;The file did not specify the _Valid column attribute&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="VelocytoLoom.plot_fractions"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.plot_fractions">[docs]</a>    <span class="k">def</span> <span class="nf">plot_fractions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">save2file</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Plots a barplot showing the abundance of spliced/unspliced molecules in the dataset</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        save2file: str (default: None)</span>
<span class="sd">            If not None specifies the file path to wich plots get saved</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing, it plots a barplot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">3.2</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">chips</span><span class="p">,</span> <span class="n">chip_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ca</span><span class="p">[</span><span class="s2">&quot;SampleID&quot;</span><span class="p">],</span> <span class="n">return_inverse</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">chips</span><span class="p">,</span> <span class="n">chip_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ca</span><span class="p">[</span><span class="s2">&quot;CellID&quot;</span><span class="p">]],</span> <span class="n">return_inverse</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chips</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">chip_ix</span><span class="p">):</span>
            <span class="n">tot_mol_cell_submatrixes</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">[:,</span> <span class="n">chip_ix</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">X</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">]]</span>
            <span class="n">total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tot_mol_cell_submatrixes</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">_mean</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">j</span> <span class="o">/</span> <span class="n">total</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">tot_mol_cell_submatrixes</span><span class="p">]</span>
            <span class="n">_std</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">j</span> <span class="o">/</span> <span class="n">total</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">tot_mol_cell_submatrixes</span><span class="p">]</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Fraction&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">n</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">_mean</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mf">1.05</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="n">chips</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">n</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">_mean</span><span class="p">,</span> <span class="n">_std</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">capsize</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

            <span class="c1"># Hide the right and top spines</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># Only show ticks on the left and bottom spines</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_bounds</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            
        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="p">[</span><span class="s2">&quot;spliced&quot;</span><span class="p">,</span> <span class="s2">&quot;ambiguous&quot;</span><span class="p">,</span> <span class="s2">&quot;unspliced&quot;</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">save2file</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">save2file</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s2">&quot;tight&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.filter_cells"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.filter_cells">[docs]</a>    <span class="k">def</span> <span class="nf">filter_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bool_array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Filter cells using a boolean array. </span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        bool_array: np.ndarray (size )</span>
<span class="sd">            array describing the cells to keep (True).</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        Nothing but it removes some cells from S and U.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">bool_array</span><span class="p">]</span> <span class="k">for</span> <span class="n">X</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ca</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="n">bool_array</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span><span class="p">[</span><span class="n">bool_array</span><span class="p">]</span>  <span class="c1"># type: np.ndarray</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span></div>

<div class="viewcode-block" id="VelocytoLoom.set_clusters"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.set_clusters">[docs]</a>    <span class="k">def</span> <span class="nf">set_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_labels</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">cluster_colors_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">colormap</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Utility function to set cluster labels, names and colormap</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        cluster_labels: np.ndarray</span>
<span class="sd">            A vector of strings containing the name of the cluster for each cells</span>
<span class="sd">        cluster_colors_dict: dict[str, List[float]]</span>
<span class="sd">            A mapping  cluster_name -&gt; rgb_color_triplette for example &quot;StemCell&quot;:[0.65,0.1,0.4]</span>
<span class="sd">        colormap: </span>
<span class="sd">            (optional)</span>
<span class="sd">            In alternative to cluster_colors_dict a colormap object (e.g. from matplotlib or similar callable) can be passed</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Notghing, the attributes `cluster_labels, colorandum, cluster_ix, cluster_uid` are created.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">cluster_labels</span>
        <span class="k">if</span> <span class="n">cluter_colors_dict</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">colorandum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cluter_colors_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cluster_labels</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluter_colors_dict</span> <span class="o">=</span> <span class="n">cluter_colors_dict</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">colormap</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">colormap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">colorandum</span> <span class="o">=</span> <span class="n">colormap_fun</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_ix</span><span class="p">)</span>
                <span class="n">cluster_uid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_uid</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cluter_colors_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">cluster_uid</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">colormap_fun</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster_uid</span><span class="p">))}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">colormap</span> <span class="o">=</span> <span class="n">colormap</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">colorandum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colormap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_ix</span><span class="p">)</span>
                <span class="n">cluster_uid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_uid</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cluter_colors_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">cluster_uid</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">colormap</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster_uid</span><span class="p">))}</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cluster_uid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">clusters_uid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">clusters_uid</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cluster_ix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">cluster_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cluster_ix</span>

<div class="viewcode-block" id="VelocytoLoom.score_cv_vs_mean"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.score_cv_vs_mean">[docs]</a>    <span class="k">def</span> <span class="nf">score_cv_vs_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span> <span class="n">min_expr_cells</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_expr_avg</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">svr_gamma</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">winsorize</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">winsor_perc</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">99.5</span><span class="p">),</span> <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Rank genes on the basis of a CV vs mean fit, it uses a nonparametric fit (Support Vector Regression)</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        N: int</span>
<span class="sd">            the number to select</span>
<span class="sd">        min_expr_cells: int</span>
<span class="sd">            minimum number of cells that express that gene for it to be considered in the fit</span>
<span class="sd">        max_expr_avg: float</span>
<span class="sd">            The maximum average accepted before discarding from the the gene as house-keeping/outlier</span>
<span class="sd">        svr_gamma: float</span>
<span class="sd">            the gamma hyperparameter of the SVR</span>
<span class="sd">        winsorize: bool</span>
<span class="sd">            Wether to winsorize the data for the cv vs mean model</span>
<span class="sd">        winsor_perc: tuple, default=(1, 99.5)</span>
<span class="sd">            the up and lower bound of the winsorization</span>
<span class="sd">        plot: bool, default=False</span>
<span class="sd">            whether to show a plot</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but it creates the attributes</span>
<span class="sd">        cv_mean_score: np.ndarray</span>
<span class="sd">            How much the observed CV is higher than the one predicted by a noise model fit to the data</span>
<span class="sd">        cv_mean_selected: np.ndarray bool</span>
<span class="sd">            on the basis of the N parameter</span>

<span class="sd">        Note: genes excluded from the fit will have in the output the same score as the less noisy gene in the dataset.</span>

<span class="sd">        To perform the filtering use the method `filter_genes`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">winsorize</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">min_expr_cells</span> <span class="o">&lt;=</span> <span class="p">((</span><span class="mi">100</span> <span class="o">-</span> <span class="n">winsor_perc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.01</span><span class="p">):</span>
                <span class="n">min_expr_cells</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="mi">100</span> <span class="o">-</span> <span class="n">winsor_perc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.01</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;min_expr_cells is too low for winsorization with upper_perc =</span><span class="si">{winsor_perc[0]}</span><span class="s2">, ugrading to min_expr_cells =</span><span class="si">{min_expr_cells}</span><span class="s2">&quot;</span><span class="p">)</span>
                
        <span class="n">detected_bool</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">min_expr_cells</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_expr_avg</span><span class="p">)</span>
        <span class="n">Sf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">detected_bool</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="n">winsorize</span><span class="p">:</span>
            <span class="n">down</span><span class="p">,</span> <span class="n">up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">Sf</span><span class="p">,</span> <span class="n">winsor_perc</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">Sfw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">Sf</span><span class="p">,</span> <span class="n">down</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">up</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">Sfw</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">Sfw</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">Sf</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">Sf</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">cv</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">/</span> <span class="n">mu</span>
        <span class="n">log_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
        <span class="n">log_cv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">cv</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">svr_gamma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">svr_gamma</span> <span class="o">=</span> <span class="mf">150.</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;svr_gamma set to </span><span class="si">{svr_gamma}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Fit the Support Vector Regression</span>
        <span class="n">clf</span> <span class="o">=</span> <span class="n">SVR</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="n">svr_gamma</span><span class="p">)</span>
        <span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">log_m</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">log_cv</span><span class="p">)</span>
        <span class="n">fitted_fun</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span>
        <span class="n">ff</span> <span class="o">=</span> <span class="n">fitted_fun</span><span class="p">(</span><span class="n">log_m</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">log_cv</span> <span class="o">-</span> <span class="n">ff</span>
        <span class="n">nth_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">score</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">N</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">scatter_viz</span><span class="p">(</span><span class="n">log_m</span><span class="p">[</span><span class="n">score</span> <span class="o">&gt;</span> <span class="n">nth_score</span><span class="p">],</span> <span class="n">log_cv</span><span class="p">[</span><span class="n">score</span> <span class="o">&gt;</span> <span class="n">nth_score</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;tab:red&quot;</span><span class="p">)</span>
            <span class="n">scatter_viz</span><span class="p">(</span><span class="n">log_m</span><span class="p">[</span><span class="n">score</span> <span class="o">&lt;=</span> <span class="n">nth_score</span><span class="p">],</span> <span class="n">log_cv</span><span class="p">[</span><span class="n">score</span> <span class="o">&lt;=</span> <span class="n">nth_score</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;tab:blue&quot;</span><span class="p">)</span>
            <span class="n">mu_linspace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">log_m</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">log_m</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">mu_linspace</span><span class="p">,</span> <span class="n">fitted_fun</span><span class="p">(</span><span class="n">mu_linspace</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]),</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">detected_bool</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_score</span><span class="p">[</span><span class="o">~</span><span class="n">detected_bool</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">score</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1e-16</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_score</span><span class="p">[</span><span class="n">detected_bool</span><span class="p">]</span> <span class="o">=</span> <span class="n">score</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_selected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_score</span> <span class="o">&gt;=</span> <span class="n">nth_score</span></div>

<div class="viewcode-block" id="VelocytoLoom.score_cluster_expression"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.score_cluster_expression">[docs]</a>    <span class="k">def</span> <span class="nf">score_cluster_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_avg_U</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">min_avg_S</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.08</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Prepare filtering genes on the basis of cluster-wise expression threshold</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        min_avg_U: float</span>
<span class="sd">            Include genes that have unspliced average bigger than `min_avg_U` in at least one of the clusters</span>
<span class="sd">        min_avg_S: float</span>
<span class="sd">            Include genes that have spliced average bigger than `min_avg_U` in at least one of the clusters</span>
<span class="sd">        Note: the two conditions are combined by and &quot;&amp;&quot; logical operator</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but it creates the attribute</span>
<span class="sd">        clu_avg_selected: np.ndarray bool</span>
<span class="sd">            The gene cluster that is selected</span>
<span class="sd">        To perform the filtering use the method `filter_genes`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U_avgs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_avgs</span> <span class="o">=</span> <span class="n">clusters_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_uid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_ix</span><span class="p">,</span> <span class="n">size_limit</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clu_avg_selected</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_avgs</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">min_avg_U</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_avgs</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">min_avg_S</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.score_detection_levels"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.score_detection_levels">[docs]</a>    <span class="k">def</span> <span class="nf">score_detection_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_expr_counts</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="n">min_cells_express</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
                               <span class="n">min_expr_counts_U</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">min_cells_express_U</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Prepare basic filtering of genes on the basis of their detection levels</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        min_expr_counts: float</span>
<span class="sd">            The minimum number of spliced molecules detected considering all the cells</span>
<span class="sd">        min_cells_express: float</span>
<span class="sd">            The minimum number of cells that express spliced molecules of a gene</span>
<span class="sd">        min_expr_counts_U: float</span>
<span class="sd">            The minimum number of unspliced molecules detected considering all the cells</span>
<span class="sd">        min_cells_express_U: float</span>
<span class="sd">            The minimum number of cells that express unspliced molecules of a gene</span>
<span class="sd">        Note: the conditions are combined by and &quot;&amp;&quot; logical operator</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but an attribute self.detection_level_selected is created</span>
<span class="sd">        To perform the filtering by detection levels use the method `filter_genes`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Some basic filtering</span>
        <span class="n">S_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">S_ncells_express</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">U_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">U_ncells_express</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">filter_bool</span> <span class="o">=</span> <span class="p">(</span><span class="n">S_sum</span> <span class="o">&gt;=</span> <span class="n">min_expr_counts</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">S_ncells_express</span> <span class="o">&gt;=</span> <span class="n">min_cells_express</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">U_sum</span> <span class="o">&gt;=</span> <span class="n">min_expr_counts_U</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">U_ncells_express</span> <span class="o">&gt;=</span> <span class="n">min_cells_express_U</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">detection_level_selected</span> <span class="o">=</span> <span class="n">filter_bool</span></div>

<div class="viewcode-block" id="VelocytoLoom.filter_genes"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.filter_genes">[docs]</a>    <span class="k">def</span> <span class="nf">filter_genes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">by_detection_levels</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">by_cluster_expression</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">by_cv_vs_mean</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">by_custom_array</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep_unfiltered</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Filter genes taking care that all the matrixes and all the connected annotation get filtered accordingly</span>

<span class="sd">        Attributes affected: .U, .S, .ra</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        by_detection_levels: bool, default=False</span>
<span class="sd">            filter genes by the score_detection_levels result</span>

<span class="sd">        by_cluster_expression: bool, default=False</span>
<span class="sd">            filter genes by the score_cluster_expression result</span>

<span class="sd">        by_cv_vs_mean: bool, default=False</span>
<span class="sd">            filter genes by the score_cluster_expression result</span>

<span class="sd">        by_custom_array, np.ndarray, default=None</span>
<span class="sd">            provide a boolean or index array</span>

<span class="sd">        keep_unfiltered: bool, default=False</span>
<span class="sd">            whether to create attributes self.S_prefilter, self.U_prefilter, self.ra_prefilter,</span>
<span class="sd">            (array will be made sparse to minimize memory footprint)</span>
<span class="sd">            or just overwrite the previous arrays</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but it updates the self.S, self.U, self.ra attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="n">by_detection_levels</span><span class="p">,</span> <span class="n">by_cluster_expression</span><span class="p">,</span>
                       <span class="n">by_cv_vs_mean</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">by_custom_array</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)]),</span> <span class="s2">&quot;At least one of the filtering methods needs to be True&quot;</span>
        <span class="n">tmp_filter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">by_cluster_expression</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;clu_avg_selected&quot;</span><span class="p">),</span> <span class="s2">&quot;clu_avg_selected was not found&quot;</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Filtering by cluster expression&quot;</span><span class="p">)</span>
            <span class="n">tmp_filter</span> <span class="o">=</span> <span class="n">tmp_filter</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">clu_avg_selected</span>
        <span class="k">if</span> <span class="n">by_cv_vs_mean</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;cv_mean_selected&quot;</span><span class="p">),</span> <span class="s2">&quot;cv_mean_selected was not found&quot;</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Filtering by cv vs mean&quot;</span><span class="p">)</span>
            <span class="n">tmp_filter</span> <span class="o">=</span> <span class="n">tmp_filter</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_selected</span>
        <span class="k">if</span> <span class="n">by_detection_levels</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;detection_level_selected&quot;</span><span class="p">),</span> <span class="s2">&quot;detection_level_selected was not found&quot;</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Filtering by detection level&quot;</span><span class="p">)</span>
            <span class="n">tmp_filter</span> <span class="o">=</span> <span class="n">tmp_filter</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">detection_level_selected</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">by_custom_array</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">by_custom_array</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Filtering by custom boolean array&quot;</span><span class="p">)</span>
                <span class="n">tmp_filter</span> <span class="o">=</span> <span class="n">tmp_filter</span> <span class="o">&amp;</span> <span class="n">by_custom_array</span>
            <span class="k">elif</span> <span class="n">by_custom_array</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Filtering by custom index array&quot;</span><span class="p">)</span>
                <span class="n">bool_negative</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tmp_filter</span><span class="p">)),</span> <span class="n">by_custom_array</span><span class="p">)</span>
                <span class="n">tmp_filter</span><span class="p">[</span><span class="n">bool_negative</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">keep_unfiltered</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;U_prefilter&quot;</span><span class="p">):</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Attributes *_prefilter are already present and were overwritten&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U_prefilter</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S_prefilter</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ra_prefilter</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="n">tmp_filter</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">tmp_filter</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ra</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="n">tmp_filter</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>

<div class="viewcode-block" id="VelocytoLoom.custom_filter_attributes"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.custom_filter_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">custom_filter_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">bool_filter</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Filter attributes given a boolean array. attr_names can be dictionaries or numpy arrays</span>
<span class="sd">        </span>
<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        attr_names: List[str]</span>
<span class="sd">            a list of the attributes to be modified. The can be</span>
<span class="sd">            1d arrays, dictionary of 1d arrays, ndarrays, will be filtered by axis=0</span>
<span class="sd">            if .T is specified by axis=-1</span>
<span class="sd">        bool_filter:</span>
<span class="sd">            the boolean filter to be applied</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing it filters the specified attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">transpose_flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attr_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">attr</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">==</span> <span class="s2">&quot;.T&quot;</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">transpose_flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
                <span class="n">transpose_flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="n">bool_filter</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">transpose_flag</span><span class="p">:</span>
                        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">obj</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">bool_filter</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">obj</span><span class="p">[</span><span class="n">bool_filter</span><span class="p">,</span> <span class="p">:])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">obj</span><span class="p">[</span><span class="n">bool_filter</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;The filtering of an object of type {type(obj)} is not defined&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_normalize_S</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">log</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pcount</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">relative_size</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_size</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Internal function for the spliced molecule filtering. The `normalize` method should be used as a standard interface&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">relative_size</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cell_size</span> <span class="o">=</span> <span class="n">relative_size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cell_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">target_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">avg_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">avg_size</span> <span class="o">=</span> <span class="n">target_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">avg_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm_factor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span> <span class="o">+</span> <span class="n">pcount</span><span class="p">)</span>  <span class="c1"># np.sqrt(S_sz )# np.log2(S_sz + 1)</span>

    <span class="k">def</span> <span class="nf">_normalize_U</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">log</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pcount</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">use_S_size</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">relative_size</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_size</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Internal function for the unspliced molecule filtering. The `normalize` method should be used as a standard interface&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_S_size</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;cell_size&quot;</span><span class="p">):</span>
                    <span class="n">cell_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cell_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">relative_size</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="n">cell_size</span> <span class="o">=</span> <span class="n">relative_size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cell_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ucell_size</span> <span class="o">=</span> <span class="n">cell_size</span>
            <span class="k">if</span> <span class="n">target_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">avg_size</span> <span class="o">=</span> <span class="n">cell_size</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">avg_size</span> <span class="o">=</span> <span class="n">target_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Uavg_size</span> <span class="o">=</span> <span class="n">avg_size</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
                <span class="n">norm_factor</span> <span class="o">=</span> <span class="n">avg_size</span> <span class="o">/</span> <span class="n">cell_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">norm_factor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Unorm_factor</span> <span class="o">=</span> <span class="n">norm_factor</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span> <span class="o">=</span> <span class="n">norm_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># it happened only once but it is here as a precaution</span>
        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span> <span class="o">+</span> <span class="n">pcount</span><span class="p">)</span>  <span class="c1"># np.sqrt(S_sz )# np.log2(S_sz + 1)</span>

    <span class="k">def</span> <span class="nf">_normalize_Sx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">log</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pcount</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">relative_size</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_size</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Internal function for the smoothed spliced molecule filtering. The `normalize` method should be used as a standard interface&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">relative_size</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xcell_size</span> <span class="o">=</span> <span class="n">relative_size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xcell_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">target_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xavg_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xcell_size</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xavg_size</span> <span class="o">=</span> <span class="n">target_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xnorm_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xavg_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">xcell_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xnorm_factor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xnorm_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span>
        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sx_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span> <span class="o">+</span> <span class="n">pcount</span><span class="p">)</span>  <span class="c1"># np.sqrt(S_sz )# np.log2(S_sz + 1)</span>

    <span class="k">def</span> <span class="nf">_normalize_Ux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">log</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pcount</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">use_Sx_size</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">relative_size</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_size</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Internal function for the smoothed unspliced molecule filtering. The `normalize` method should be used as a standard interface&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_Sx_size</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;cell_size&quot;</span><span class="p">):</span>
                    <span class="n">cell_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xcell_size</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cell_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">relative_size</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="n">cell_size</span> <span class="o">=</span> <span class="n">relative_size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cell_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xUcell_size</span> <span class="o">=</span> <span class="n">cell_size</span>
            <span class="k">if</span> <span class="n">target_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">avg_size</span> <span class="o">=</span> <span class="n">cell_size</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">avg_size</span> <span class="o">=</span> <span class="n">target_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xUavg_size</span> <span class="o">=</span> <span class="n">avg_size</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
                <span class="n">norm_factor</span> <span class="o">=</span> <span class="n">avg_size</span> <span class="o">/</span> <span class="n">cell_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">norm_factor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xUnorm_factor</span> <span class="o">=</span> <span class="n">norm_factor</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span> <span class="o">=</span> <span class="n">norm_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># it happened only once but it is here as a precaution</span>
        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ux_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span> <span class="o">+</span> <span class="n">pcount</span><span class="p">)</span>  <span class="c1"># np.sqrt(S_sz )# np.log2(S_sz + 1)</span>

<div class="viewcode-block" id="VelocytoLoom.normalize"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.normalize">[docs]</a>    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">log</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pcount</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                  <span class="n">relative_size</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_S_size_for_U</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">target_size</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Normalization interface</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        which: either &#39;both&#39;, &#39;S&#39;, &#39;U&#39;, &quot;imputed&quot;, &quot;Sx&quot;, &quot;Ux&quot;</span>
<span class="sd">            which attributes to normalize.</span>
<span class="sd">            &quot;both&quot; corresponds to &quot;S&quot; and &quot;U&quot;</span>
<span class="sd">            &quot;imputed&quot; corresponds to &quot;Sx&quot; and &quot;Ux&quot;</span>
<span class="sd">        size: bool</span>
<span class="sd">            perform size normalization</span>
<span class="sd">        log: bool</span>
<span class="sd">            perform log normalization (if size==True, this comes after the size normalization)</span>
<span class="sd">        pcount: int, default: 1</span>
<span class="sd">            The extra count added when logging (log2)</span>
<span class="sd">        relative_size: np.ndarray, default=None</span>
<span class="sd">            if None it calculate the sums the molecules per cell (self.S.sum(0))</span>
<span class="sd">            if an array is provided it use it for the normalization</span>
<span class="sd">        use_S_size_for_U: bool</span>
<span class="sd">            U is size normalized using the sum of molecules of S</span>
<span class="sd">        target_size: float or Tuple[float, float] (depending if the which parameter implies 1 or more normalizations)</span>
<span class="sd">            the size of the cells after normalization will be set to.</span>
<span class="sd">            If tuple the order is (S, U) or (Sx, Ux)</span>
<span class="sd">            If None the target size is the average of the cell sizes</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but creates the attributes `U_norm`, `U_sz` and `S_norm`, &quot;S_sz&quot;</span>
<span class="sd">        or `Ux_norm`, `Ux_sz` and `Sx_norm`, &quot;Sx_sz&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_S</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="n">pcount</span><span class="p">,</span> <span class="n">relative_size</span><span class="o">=</span><span class="n">relative_size</span><span class="p">,</span> <span class="n">target_size</span><span class="o">=</span><span class="n">target_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_U</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="n">pcount</span><span class="p">,</span> <span class="n">use_S_size</span><span class="o">=</span><span class="n">use_S_size_for_U</span><span class="p">,</span> <span class="n">relative_size</span><span class="o">=</span><span class="n">relative_size</span><span class="p">,</span> <span class="n">target_size</span><span class="o">=</span><span class="n">target_size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;S&quot;</span> <span class="o">==</span> <span class="n">which</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_S</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="n">pcount</span><span class="p">,</span> <span class="n">relative_size</span><span class="o">=</span><span class="n">relative_size</span><span class="p">,</span> <span class="n">target_size</span><span class="o">=</span><span class="n">target_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;U&quot;</span> <span class="o">==</span> <span class="n">which</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_U</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="n">pcount</span><span class="p">,</span> <span class="n">use_S_size</span><span class="o">=</span><span class="n">use_S_size_for_U</span><span class="p">,</span> <span class="n">relative_size</span><span class="o">=</span><span class="n">relative_size</span><span class="p">,</span> <span class="n">target_size</span><span class="o">=</span><span class="n">target_size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s2">&quot;imputed&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_Sx</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="n">pcount</span><span class="p">,</span> <span class="n">relative_size</span><span class="o">=</span><span class="n">relative_size</span><span class="p">,</span> <span class="n">target_size</span><span class="o">=</span><span class="n">target_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_Ux</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="n">pcount</span><span class="p">,</span> <span class="n">use_Sx_size</span><span class="o">=</span><span class="n">use_S_size_for_U</span><span class="p">,</span> <span class="n">relative_size</span><span class="o">=</span><span class="n">relative_size</span><span class="p">,</span> <span class="n">target_size</span><span class="o">=</span><span class="n">target_size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;Sx&quot;</span> <span class="o">==</span> <span class="n">which</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_Sx</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="n">pcount</span><span class="p">,</span> <span class="n">relative_size</span><span class="o">=</span><span class="n">relative_size</span><span class="p">,</span> <span class="n">target_size</span><span class="o">=</span><span class="n">target_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;Ux&quot;</span> <span class="o">==</span> <span class="n">which</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_Ux</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="n">pcount</span><span class="p">,</span> <span class="n">use_Sx_size</span><span class="o">=</span><span class="n">use_S_size_for_U</span><span class="p">,</span> <span class="n">relative_size</span><span class="o">=</span><span class="n">relative_size</span><span class="p">,</span> <span class="n">target_size</span><span class="o">=</span><span class="n">target_size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="VelocytoLoom.perform_PCA"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.perform_PCA">[docs]</a>    <span class="k">def</span> <span class="nf">perform_PCA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;S_norm&quot;</span><span class="p">,</span> <span class="n">n_components</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">div_by_std</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Perform PCA (cells as samples)</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        which: str, default=&quot;S_norm&quot;</span>
<span class="sd">            The name of the attribute to use for the calculation (e.g. S_norm or Sx_norm)</span>
<span class="sd">        n_components: int, default=None</span>
<span class="sd">            Number of components to keep. If None all the components will be kept.</span>
<span class="sd">        div_by_std: bool, default=False</span>
<span class="sd">            Wether to divide by standard deviation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Returns nothing but it creates the attributes:</span>
<span class="sd">        pca: np.ndarray</span>
<span class="sd">            a numpy array of shape (cells, npcs)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">div_by_std</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">X</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.normalize_by_total"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.normalize_by_total">[docs]</a>    <span class="k">def</span> <span class="nf">normalize_by_total</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_perc_U</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skip_low_U_pop</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Normalize the cells using the (initial) total molecules as size estimate</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        min_perc_U: float</span>
<span class="sd">            the percentile to use as a minimum value allowed for the size normalization</span>
<span class="sd">        plot: bool, default=False</span>
<span class="sd">            whether</span>
<span class="sd">        skip_low_U_pop: bool, default=True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Returns nothing but it creates the attributes:</span>
<span class="sd">        small_U_pop: np.ndarray</span>
<span class="sd">            Cells with extremely low unspliced count</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">target_cell_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_cell_size</span><span class="p">)</span>
        <span class="n">min_Ucell_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_Ucell_size</span><span class="p">,</span> <span class="n">min_perc_U</span><span class="p">)</span>
        <span class="n">bool_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_Ucell_size</span> <span class="o">&lt;</span> <span class="n">min_Ucell_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span> <span class="o">=</span> <span class="n">bool_f</span>
        <span class="n">target_Ucell_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_Ucell_size</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">])</span>  <span class="c1"># 0.15 * target_cell_size</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">121</span><span class="p">)</span>
            
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_cell_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_Ucell_size</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;total spliced&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;total unspliced&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_cell_size</span><span class="p">[</span><span class="n">bool_f</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_Ucell_size</span><span class="p">[</span><span class="n">bool_f</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">122</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_cell_size</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_Ucell_size</span><span class="p">),</span> <span class="n">s</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_cell_size</span><span class="p">)[</span><span class="n">bool_f</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_Ucell_size</span><span class="p">)[</span><span class="n">bool_f</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;log total spliced&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;log total unspliced&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_S</span><span class="p">(</span><span class="n">relative_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_cell_size</span><span class="p">,</span>
                          <span class="n">target_size</span><span class="o">=</span><span class="n">target_cell_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">skip_low_U_pop</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_U</span><span class="p">(</span><span class="n">relative_size</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_Ucell_size</span><span class="p">,</span> <span class="n">min_Ucell_size</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                              <span class="n">target_size</span><span class="o">=</span><span class="n">target_Ucell_size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_U</span><span class="p">(</span><span class="n">relative_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_Ucell_size</span><span class="p">,</span>
                              <span class="n">target_size</span><span class="o">=</span><span class="n">target_Ucell_size</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.adjust_totS_totU"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.adjust_totS_totU">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_totS_totU</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skip_low_U_pop</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">normalize_total</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">fit_with_low_U</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">svr_C</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">svr_gamma</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Adjust the spliced count on the base of the relation S_sz_tot and U_sz_tot</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        skip_low_U_pop: bool, default=True</span>
<span class="sd">            Do not normalize the low unspliced molecules cell population to avoid overinflated values</span>
<span class="sd">        normalize_total: bool, default=False</span>
<span class="sd">            If this is True the function results in a normalization by median of both U and S.</span>
<span class="sd">            NOTE: Legacy compatibility, I might want to split this into a different function.</span>
<span class="sd">        fit_with_low_U: bool, default=True</span>
<span class="sd">            Wether to consider the low_U population for the fit</span>
<span class="sd">        svr_C: float</span>
<span class="sd">            The C parameter of scikit-learn Support Vector Regression</span>
<span class="sd">        svr_gamma: float</span>
<span class="sd">            The gamma parameter of scikit-learn Support Vector Regression</span>
<span class="sd">        plot: bool</span>
<span class="sd">            Whether to plot the results of the fit</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but it modifies the attributes:</span>
<span class="sd">        U_sz: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">svr</span> <span class="o">=</span> <span class="n">SVR</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="n">svr_C</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="s2">&quot;rbf&quot;</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="n">svr_gamma</span><span class="p">)</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fit_with_low_U</span><span class="p">:</span>
            <span class="n">svr</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">predicted</span> <span class="o">=</span> <span class="n">svr</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">svr</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">])</span>
            <span class="n">predicted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">predicted</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span> <span class="o">=</span> <span class="n">svr</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
            
        <span class="n">adj_factor</span> <span class="o">=</span> <span class="n">predicted</span> <span class="o">/</span> <span class="n">y</span>
        <span class="n">adj_factor</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">adj_factor</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">skip_low_U_pop</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span> <span class="o">*</span> <span class="n">adj_factor</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span> <span class="o">*</span> <span class="n">adj_factor</span>

        <span class="k">if</span> <span class="n">normalize_total</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">normalize_median</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s2">&quot;renormalize&quot;</span><span class="p">,</span> <span class="n">skip_low_U_pop</span><span class="o">=</span><span class="n">skip_low_U_pop</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">predicted</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.normalize_median"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.normalize_median">[docs]</a>    <span class="k">def</span> <span class="nf">normalize_median</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;imputed&quot;</span><span class="p">,</span> <span class="n">skip_low_U_pop</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Normalize cell size to the median, for both S and U.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        which: str, default=&quot;imputed&quot;</span>
<span class="sd">            &quot;imputed&quot; or &quot;renormalized&quot;</span>
<span class="sd">        skip_low_U_pop: bool=True</span>
<span class="sd">            Whether to skip the low U population defined in normalize_by_total</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but it modifies the attributes:</span>
<span class="sd">        S_sz: np.ndarray</span>
<span class="sd">        U_sz: np.ndarray</span>
<span class="sd">        or</span>
<span class="sd">        Sx_sz: np.ndarray</span>
<span class="sd">        Ux_sz: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s2">&quot;renormalize&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">skip_low_U_pop</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">which</span> <span class="o">==</span> <span class="s2">&quot;imputed&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            
            <span class="k">if</span> <span class="n">skip_low_U_pop</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ux</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ux</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ux</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span></div>

<div class="viewcode-block" id="VelocytoLoom.plot_pca"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.plot_pca">[docs]</a>    <span class="k">def</span> <span class="nf">plot_pca</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">elev</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">azim</span><span class="p">:</span> <span class="nb">float</span><span class="o">=-</span><span class="mi">140</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Plot 3d PCA</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcs</span><span class="p">[:,</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">pcs</span><span class="p">[:,</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">pcs</span><span class="p">[:,</span> <span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                   <span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">colorandum</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="n">elev</span><span class="p">,</span> <span class="n">azim</span><span class="o">=</span><span class="n">azim</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.perform_PCA_imputed"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.perform_PCA_imputed">[docs]</a>    <span class="k">def</span> <span class="nf">perform_PCA_imputed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_components</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Simply performs PCA of `Sx_norm` and save the result as  `pcax`&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcax</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcax</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx_norm</span><span class="o">.</span><span class="n">T</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.plot_pca_imputed"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.plot_pca_imputed">[docs]</a>    <span class="k">def</span> <span class="nf">plot_pca_imputed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">elev</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">azim</span><span class="p">:</span> <span class="nb">float</span><span class="o">=-</span><span class="mi">140</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Plot 3d PCA of the smoothed data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcsx</span><span class="p">[:,</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">pcsx</span><span class="p">[:,</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">pcsx</span><span class="p">[:,</span> <span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                   <span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">colorandum</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="n">elev</span><span class="p">,</span> <span class="n">azim</span><span class="o">=</span><span class="n">azim</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.knn_imputation"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.knn_imputation">[docs]</a>    <span class="k">def</span> <span class="nf">knn_imputation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pca_space</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">metric</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span> <span class="n">diag</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                       <span class="n">n_pca_dims</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maximum</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">size_norm</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">balanced</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">b_sight</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">b_maxl</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Performs k-nn smoothing of the data matrix</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        k: int</span>
<span class="sd">            number of neighbors. If None the default it is chosen to be `0.025 * Ncells`</span>
<span class="sd">        pca_space: bool, default=True</span>
<span class="sd">            if True the knn will be performed in PCA space (`pcs`)</span>
<span class="sd">            otherwise it will use log2 size normalized data  (`S_norm`)</span>
<span class="sd">        metric: str</span>
<span class="sd">            &quot;euclidean&quot; or &quot;correlation&quot;</span>
<span class="sd">        diag: int, default=1</span>
<span class="sd">            before smoothing this value is substituted in the diagonal of the knn contiguity matrix</span>
<span class="sd">            Resulting in a reduction of the smoothing effect.</span>
<span class="sd">            E.g. if diag=8 and k=10 value of Si = (8 * S_i + sum(S_n, with n in 5nn of i)) / (8+5)</span>
<span class="sd">        maximum: bool, default=False</span>
<span class="sd">            If True the maximum value of the smoothing and the original matrix entry is taken.</span>
<span class="sd">        n_pca_dims: int, default=None</span>
<span class="sd">            number of pca to use for the knn distance metric. If None all pcs will be used. (used only if pca_space == True)</span>
<span class="sd">        balanced: bool</span>
<span class="sd">            whether to use BalancedKNN version</span>
<span class="sd">        b_sight: int</span>
<span class="sd">            the sight parameter of BalancedKNN (used only if balanced == True)</span>
<span class="sd">        b_maxl: int</span>
<span class="sd">            the maxl parameter of BalancedKNN (used only if balanced == True)</span>
<span class="sd">        n_jobs: int, default 8</span>
<span class="sd">            number of parallel jobs in knn calculation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but it creates the attributes:</span>
<span class="sd">        knn: scipy.sparse.csr_matrix </span>
<span class="sd">            knn contiguity matrix</span>
<span class="sd">        knn_smoothig_w: scipy.sparse.lil_matrix</span>
<span class="sd">            the weights used for the smoothing</span>
<span class="sd">        Sx: np.ndarray</span>
<span class="sd">            smoothed spliced</span>
<span class="sd">        Ux: np.ndarray</span>
<span class="sd">            smoothed unspliced</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="mf">0.025</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">b_sight</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">balanced</span><span class="p">:</span>
            <span class="n">b_sight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="mi">8</span><span class="p">),</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">b_maxl</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">balanced</span><span class="p">:</span>
            <span class="n">b_maxl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="mi">4</span><span class="p">),</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pca_space</span><span class="p">:</span>
            <span class="n">space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcs</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n_pca_dims</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_norm</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="n">balanced</span><span class="p">:</span>
            <span class="n">bknn</span> <span class="o">=</span> <span class="n">BalancedKNN</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">sight_k</span><span class="o">=</span><span class="n">b_sight</span><span class="p">,</span> <span class="n">maxl</span><span class="o">=</span><span class="n">b_maxl</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
            <span class="n">bknn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">space</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">knn</span> <span class="o">=</span> <span class="n">bknn</span><span class="o">.</span><span class="n">kneighbors_graph</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">knn</span> <span class="o">=</span> <span class="n">knn_distance_matrix</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">connectivity</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>  <span class="c1"># SparseEfficiencyWarning: Changing the sparsity structure of a csr_matrix is expensive. lil_matrix is more efficient.</span>
            <span class="n">connectivity</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="n">diag</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_smoothig_w</span> <span class="o">=</span> <span class="n">connectivity_to_weights</span><span class="p">(</span><span class="n">connectivity</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size_norm</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">=</span> <span class="n">convolve_by_sparse_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_smoothig_w</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span> <span class="o">=</span> <span class="n">convolve_by_sparse_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_smoothig_w</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">=</span> <span class="n">convolve_by_sparse_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_smoothig_w</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span> <span class="o">=</span> <span class="n">convolve_by_sparse_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_smoothig_w</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maximum</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.knn_imputation_precomputed"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.knn_imputation_precomputed">[docs]</a>    <span class="k">def</span> <span class="nf">knn_imputation_precomputed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">knn_smoothig_w</span><span class="p">:</span> <span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">,</span> <span class="n">maximum</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Performs k-nn imputation (like `.knn_imputation()`) but with a precomputed weight matrix</span>
<span class="sd">        </span>
<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        knn_smoothig_w: sparse.lil_matrix</span>
<span class="sd">            the sparse matrix to be convolved with self.S_sz and self.U_sz</span>
<span class="sd">            This should be the result of somethign like:</span>
<span class="sd">            connectivity.setdiag(diagonal_value)</span>
<span class="sd">            knn_smoothig_w = connectivity_to_weights(connectivity)</span>
<span class="sd">        maximum: bool, default=False</span>
<span class="sd">            whether to take the maximum value of the smoothing and the original matrix</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but it creates the attributes:</span>
<span class="sd">        Sx: np.ndarray</span>
<span class="sd">            smoothed spliced</span>
<span class="sd">        Ux: np.ndarray</span>
<span class="sd">            smoothed unspliced</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">=</span> <span class="n">convolve_by_sparse_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span><span class="p">,</span> <span class="n">knn_smoothig_w</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span> <span class="o">=</span> <span class="n">convolve_by_sparse_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">,</span> <span class="n">knn_smoothig_w</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maximum</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.gene_knn_imputation"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.gene_knn_imputation">[docs]</a>    <span class="k">def</span> <span class="nf">gene_knn_imputation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">pca_space</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">metric</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;correlation&quot;</span><span class="p">,</span> <span class="n">diag</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                            <span class="n">scale_weights</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">balanced</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">b_sight</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">b_maxl</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">18</span><span class="p">,</span>
                             <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Performs genes k-nn smoothing of the genes</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        k: int, default=15</span>
<span class="sd">            number of neighbors</span>
<span class="sd">        pca_space: bool, default=False</span>
<span class="sd">            if True the knn will be performed in PCA space (`pcs`)</span>
<span class="sd">            otherwise it will use log2 size normalized data  (`S_norm`)</span>
<span class="sd">        metric: str, default=&quot;correlation&quot;</span>
<span class="sd">            &quot;euclidean&quot; or &quot;correlation&quot;</span>
<span class="sd">        diag: int, default=1</span>
<span class="sd">            before smoothing this value is substituted in the diagonal of the knn contiguity matrix</span>
<span class="sd">            Resulting in a reduction of the smoothing effect</span>
<span class="sd">            E.g. if diag=8 and k=10 value of Si = (8 * S_i + sum(S_n, with n in 5nn of i)) / (8+5)</span>
<span class="sd">        scale_weights: bool, default=True</span>
<span class="sd">            whether to scale weights by gene total expression/yield</span>
<span class="sd">        balanced: bool, default=True</span>
<span class="sd">            whether to use BalancedKNN version</span>
<span class="sd">        b_sight: int, default=100</span>
<span class="sd">            the sight parameter of BalancedKNN (used only if balanced == True)</span>
<span class="sd">        b_maxl: int, default=18</span>
<span class="sd">            the maxl parameter of BalancedKNN (used only if balanced == True)</span>
<span class="sd">        n_jobs: int, default=8</span>
<span class="sd">            number of parallel jobs in knn calculation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but it creates the attributes:</span>
<span class="sd">        gknn: scipy.sparse.csr_matrix </span>
<span class="sd">            genes knn contiguity matrix</span>
<span class="sd">        gknn_smoothig_w: scipy.sparse.lil_matrix</span>
<span class="sd">            the weights used for the smoothing of the genes</span>
<span class="sd">        Sx: np.ndarray</span>
<span class="sd">            smoothed spliced</span>
<span class="sd">        Ux: np.ndarray</span>
<span class="sd">            smoothed unspliced</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pca_space</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ne">NotImplementedError</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span>  <span class="c1"># imputed size normalized counts</span>
        <span class="k">if</span> <span class="n">balanced</span><span class="p">:</span>
            <span class="n">bknn</span> <span class="o">=</span> <span class="n">BalancedKNN</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">sight_k</span><span class="o">=</span><span class="n">b_sight</span><span class="p">,</span> <span class="n">maxl</span><span class="o">=</span><span class="n">b_maxl</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
            <span class="n">bknn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">space</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gknn</span> <span class="o">=</span> <span class="n">bknn</span><span class="o">.</span><span class="n">kneighbors_graph</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gknn</span> <span class="o">=</span> <span class="n">knn_distance_matrix</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">connectivity</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">atype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="n">connectivity</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="n">diag</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gknn_smoothig_w</span> <span class="o">=</span> <span class="n">connectivity_to_weights</span><span class="p">(</span><span class="n">connectivity</span><span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">scale_weights</span><span class="p">:</span>
            <span class="n">genes_total</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gknn_smoothig_w</span> <span class="o">=</span> <span class="n">scale_to_match_median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gknn_smoothig_w</span><span class="p">,</span> <span class="n">genes_total</span><span class="p">)</span>
        <span class="c1"># NOTE This might be not computationally efficient after transpose, maybe better to use csc for the genes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span> <span class="o">=</span> <span class="n">convolve_by_sparse_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gknn_smoothig_w</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span> <span class="o">=</span> <span class="n">convolve_by_sparse_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gknn_smoothig_w</span><span class="p">)</span><span class="o">.</span><span class="n">T</span></div>
        
<div class="viewcode-block" id="VelocytoLoom.fit_gammas"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.fit_gammas">[docs]</a>    <span class="k">def</span> <span class="nf">fit_gammas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steady_state_bool</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_imputed_data</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_size_norm</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">fit_offset</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fixperc_q</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weighted</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">weights</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="s2">&quot;maxmin_diag&quot;</span><span class="p">,</span>
                   <span class="n">limit_gamma</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">maxmin_perc</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">98</span><span class="p">],</span> <span class="n">maxmin_weighted_pow</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Fit gamma using spliced and unspliced data</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        steady_state_bool: np.ndarray, default=None</span>
<span class="sd">            if a boolean array is specified, gamma is fitted using only the corresponding cells</span>
<span class="sd">        use_imputed_data: bool, default=True</span>
<span class="sd">            use knn smoothed data</span>
<span class="sd">        use_size_norm: bool, default=False</span>
<span class="sd">            use size normalized data for the fit</span>
<span class="sd">        fit_offset: bool, default=True</span>
<span class="sd">            Fit with offset</span>
<span class="sd">        fixperc_q: bool, default=False</span>
<span class="sd">            (when fit_offset==False) Wether to fix the offset to a lower percentile of the unspliced</span>
<span class="sd">        weighted: bool, default=True</span>
<span class="sd">            use weights for the least squares fit</span>
<span class="sd">        weights: string or np.ndarray, default=&quot;maxmin_diag&quot;</span>
<span class="sd">            the method to determine the weights of the least squares fit.</span>
<span class="sd">            &quot;maxmin_diag&quot;, &quot;maxmin&quot;, &quot;sum&quot;, &quot;prod&quot;, &quot;maxmin_weighted&quot; are supported</span>
<span class="sd">            if a 2d np.ndarray is provided the entry (i,j) is the weight of the cell j when fitting gamma to gene i </span>
<span class="sd">        limit_gamma: np.ndarray, default=True</span>
<span class="sd">            whether to limit gamma when unspliced is much higher than spliced</span>
<span class="sd">        maxmin_perc: List[flaot], default=[2,98]</span>
<span class="sd">            the percentile to use if weights = &quot;maxmin&quot; or &quot;maxmin_diag&quot;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing it just creates the attributes:</span>
<span class="sd">        gammas: np.ndarray</span>
<span class="sd">            the vector of the gammas fit to each gene</span>
<span class="sd">        q: np.ndarray</span>
<span class="sd">            the vector of offsets of the fit</span>
<span class="sd">        R2: np.ndarray (optional)</span>
<span class="sd">            The vector of squared coefficient of determination</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">steady_state_bool</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span> <span class="o">=</span> <span class="n">steady_state_bool</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_imputed_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_size_norm</span><span class="p">:</span>
                <span class="n">tmpS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span>
                <span class="n">tmpU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmpS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span>
                <span class="n">tmpU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_size_norm</span><span class="p">:</span>
                <span class="n">tmpS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span>
                <span class="n">tmpU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmpS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
                <span class="n">tmpU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span>

        <span class="k">if</span> <span class="n">weighted</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">weights</span>
            <span class="k">elif</span> <span class="n">weights</span> <span class="o">==</span> <span class="s2">&quot;sum&quot;</span><span class="p">:</span>
                <span class="n">W</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmpS</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">tmpS</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">tmpU</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">tmpU</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">weights</span> <span class="o">==</span> <span class="s2">&quot;prod&quot;</span><span class="p">:</span>
                <span class="n">W</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmpS</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">tmpS</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">tmpU</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">tmpU</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">weights</span> <span class="o">==</span> <span class="s2">&quot;maxmin_weighted&quot;</span><span class="p">:</span>
                <span class="c1"># Slightly smoother than just takin top and bottom percentile</span>
                <span class="n">down</span><span class="p">,</span> <span class="n">up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">tmpS</span><span class="p">,</span> <span class="n">maxmin_perc</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Do this asymmetrically, data is sparse!</span>
                <span class="n">Srange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">tmpS</span><span class="p">,</span> <span class="n">down</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">up</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span>
                <span class="n">Srange</span> <span class="o">-=</span> <span class="n">Srange</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="n">Srange</span> <span class="o">/=</span> <span class="n">Srange</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="n">W</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">Srange</span><span class="o">**</span><span class="n">maxmin_weighted_pow</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">Srange</span><span class="p">)</span><span class="o">**</span><span class="n">maxmin_weighted_pow</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">weights</span> <span class="o">==</span> <span class="s2">&quot;maxmin&quot;</span><span class="p">:</span>
                <span class="n">down</span><span class="p">,</span> <span class="n">up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">tmpS</span><span class="p">,</span> <span class="n">maxmin_perc</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Do this asymmetrically, data is sparse!</span>
                <span class="n">W</span> <span class="o">=</span> <span class="p">((</span><span class="n">tmpS</span> <span class="o">&lt;=</span> <span class="n">down</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">tmpS</span> <span class="o">&gt;=</span> <span class="n">up</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">weights</span> <span class="o">==</span> <span class="s2">&quot;maxmin_diag&quot;</span><span class="p">:</span>
                <span class="n">Sx_maxnorm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx</span><span class="p">,</span> <span class="mf">99.9</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="n">Ux_maxnorm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ux</span><span class="p">,</span> <span class="mf">99.9</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">Sx_maxnorm</span> <span class="o">+</span> <span class="n">Ux_maxnorm</span>
                <span class="n">down</span><span class="p">,</span> <span class="n">up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">maxmin_perc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">W</span> <span class="o">=</span> <span class="p">((</span><span class="n">X</span> <span class="o">&lt;=</span> <span class="n">down</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">X</span> <span class="o">&gt;=</span> <span class="n">up</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">weights</span> <span class="o">==</span> <span class="s2">&quot;maxmin_double&quot;</span><span class="p">:</span>
                <span class="n">Sx_maxnorm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx</span><span class="p">,</span> <span class="mf">99.9</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="n">Ux_maxnorm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ux</span><span class="p">,</span> <span class="mf">99.9</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">Sx_maxnorm</span> <span class="o">+</span> <span class="n">Ux_maxnorm</span>
                <span class="n">down</span><span class="p">,</span> <span class="n">up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">maxmin_perc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">W</span> <span class="o">=</span> <span class="p">((</span><span class="n">X</span> <span class="o">&lt;=</span> <span class="n">down</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">X</span> <span class="o">&gt;=</span> <span class="n">up</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">down</span><span class="p">,</span> <span class="n">up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx</span><span class="p">,</span> <span class="n">maxmin_perc</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">W</span> <span class="o">+=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">&lt;=</span> <span class="n">down</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">&gt;=</span> <span class="n">up</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="n">fit_offset</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">weighted</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gammas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R2</span> <span class="o">=</span> <span class="n">fit_slope_weighted_offset</span><span class="p">(</span><span class="n">tmpU</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">],</span>
                                                                         <span class="n">tmpS</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">],</span>
                                                                         <span class="n">W</span><span class="p">,</span>
                                                                         <span class="n">return_R2</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                         <span class="n">limit_gamma</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gammas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">fit_slope_offset</span><span class="p">(</span><span class="n">tmpU</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">],</span>
                                                       <span class="n">tmpS</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">fixperc_q</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">weighted</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gammas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">fit_slope_weighted_offset</span><span class="p">(</span><span class="n">tmpU</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">],</span>
                                                                <span class="n">tmpS</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">],</span>
                                                                <span class="n">W</span><span class="p">,</span> <span class="n">fixperc_q</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gammas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">fit_slope_offset</span><span class="p">(</span><span class="n">tmpU</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">],</span>
                                                       <span class="n">tmpS</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">],</span>
                                                       <span class="n">fixperc_q</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">weighted</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gammas</span> <span class="o">=</span> <span class="n">fit_slope_weighted</span><span class="p">(</span><span class="n">tmpU</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">],</span>
                                                 <span class="n">tmpS</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">],</span>
                                                 <span class="n">W</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gammas</span> <span class="o">=</span> <span class="n">fit_slope</span><span class="p">(</span><span class="n">tmpU</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">],</span>
                                        <span class="n">tmpS</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">])</span></div>

<div class="viewcode-block" id="VelocytoLoom.filter_genes_good_fit"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.filter_genes_good_fit">[docs]</a>    <span class="k">def</span> <span class="nf">filter_genes_good_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minR</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">min_gamma</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Use the coefficient of determination to filter away genes that have an irregular/complex phase portrait</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        minR: float, default=0.1</span>
<span class="sd">            Minimum coefficient of determination allowed</span>
<span class="sd">        min_gamma: float, default=0.01</span>
<span class="sd">            Filter away low gammas as a secondary filter</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but modifies it filters out the genes that do not satisfy the conditions</span>
<span class="sd">        This affects: &quot;U&quot;, &quot;U_sz&quot;, &quot;U_norm&quot;, &quot;Ux&quot;, &quot;Ux_sz&quot;, &quot;Ux_norm&quot;, &quot;S&quot;, &quot;S_sz&quot;, &quot;S_norm&quot;, &quot;Sx&quot;, &quot;Sx_sz&quot;, &quot;Sx_norm&quot;, &quot;gammas&quot;, &quot;q&quot;, &quot;R2&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># NOTE Should be: tmp_filter = np.sqrt(self.R2) &gt; minR but since the fit is weighted and constrained R2 can be negative</span>
        <span class="n">R_corrected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R2</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R2</span><span class="p">)</span>
        <span class="n">tmp_filter</span> <span class="o">=</span> <span class="n">R_corrected</span> <span class="o">&gt;</span> <span class="n">minR</span>
        <span class="n">tmp_filter</span> <span class="o">=</span> <span class="n">tmp_filter</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gammas</span> <span class="o">&gt;</span> <span class="n">min_gamma</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ra</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="n">tmp_filter</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">matrixes2filter</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;U&quot;</span><span class="p">,</span> <span class="s2">&quot;U_sz&quot;</span><span class="p">,</span> <span class="s2">&quot;U_norm&quot;</span><span class="p">,</span> <span class="s2">&quot;Ux&quot;</span><span class="p">,</span> <span class="s2">&quot;Ux_sz&quot;</span><span class="p">,</span> <span class="s2">&quot;Ux_norm&quot;</span><span class="p">,</span>
                           <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;S_sz&quot;</span><span class="p">,</span> <span class="s2">&quot;S_norm&quot;</span><span class="p">,</span> <span class="s2">&quot;Sx&quot;</span><span class="p">,</span> <span class="s2">&quot;Sx_sz&quot;</span><span class="p">,</span> <span class="s2">&quot;Sx_norm&quot;</span><span class="p">]</span>
        <span class="n">vectors2filter</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;gammas&quot;</span><span class="p">,</span> <span class="s2">&quot;q&quot;</span><span class="p">,</span> <span class="s2">&quot;R2&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">name_attr</span> <span class="ow">in</span> <span class="n">matrixes2filter</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_attr</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_attr</span><span class="p">)[</span><span class="n">tmp_filter</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">for</span> <span class="n">name_attr</span> <span class="ow">in</span> <span class="n">vectors2filter</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_attr</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_attr</span><span class="p">)[</span><span class="n">tmp_filter</span><span class="p">])</span></div>

<div class="viewcode-block" id="VelocytoLoom.predict_U"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.predict_U">[docs]</a>    <span class="k">def</span> <span class="nf">predict_U</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_gamma</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;gammas&quot;</span><span class="p">,</span> <span class="n">which_S</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span> <span class="s2">&quot;Sx_sz&quot;</span><span class="p">,</span> <span class="n">which_offset</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;q&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Predict U (gamma * S) given the gamma model fit</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        which_gamma: str, default=&quot;gammas&quot;</span>
<span class="sd">            name of the attribute to use as gamma</span>
<span class="sd">        which_S: str, default=&quot;Sx_sz&quot;</span>
<span class="sd">            name of the attribute to use as S</span>
<span class="sd">        which_offset: str, default=&quot;q&quot;</span>
<span class="sd">            name of the attribute containing the offset</span>

<span class="sd">        Returns</span>
<span class="sd">        ------</span>
<span class="sd">        Noting but it creates the attribute</span>
<span class="sd">        Upred: np.ndarray</span>
<span class="sd">           unspliced esimated as `gamma * S`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">which_S_for_pred</span> <span class="o">=</span> <span class="n">which_S</span>
        <span class="k">if</span> <span class="n">which_offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;q_W&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;q&quot;</span><span class="p">):</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Predicting U without intercept but intercept was previously fit! Set which_offset=&#39;q&#39; or &#39;q_W&#39; &quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Upred</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_gamma</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_S</span><span class="p">)</span>
            <span class="c1"># self.Upred = selg.gammas[:, None] * self.Sx_sz</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Upred</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_gamma</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_S</span><span class="p">)</span> <span class="o">+</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_offset</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span></div>

<div class="viewcode-block" id="VelocytoLoom.calculate_velocity"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.calculate_velocity">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_velocity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;residual&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calculate velocity</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        kind: str, default=&quot;residual&quot;</span>
<span class="sd">            &quot;residual&quot; calculates the velocity as U_measured - U_predicted</span>
<span class="sd">        </span>
<span class="sd">        Results</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but it creates the attribute:</span>
<span class="sd">        velocity: np.ndarray</span>
<span class="sd">            U_measured - U_predicted</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;residual&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_S_for_pred</span> <span class="o">==</span> <span class="s2">&quot;Sx_sz&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Upred</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_S_for_pred</span> <span class="o">==</span> <span class="s2">&quot;Sx&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Upred</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Not implemented with which_S = </span><span class="si">{self.which_S_for_pred}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Velocity calculation kind=</span><span class="si">{kind}</span><span class="s2"> is not implemented&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.calculate_shift"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.calculate_shift">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumption</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;constant_velocity&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;difference&quot;</span><span class="p">,</span>
                        <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">min_S</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Find the change (deltaS) in gene expression for every cell</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        assumption: str, default=&quot;constant_velocity&quot;</span>
<span class="sd">            constant_velocity (described in the paper as Model I)</span>
<span class="sd">            constant_unspliced (described in the paper as Model II)</span>
<span class="sd">        delta_t: float, default=1</span>
<span class="sd">            the time step for extrapolation</span>
<span class="sd">        kind: str, default=&quot;difference&quot;</span>
<span class="sd">            For now only difference is supported. (DEPRECATED)</span>
<span class="sd">        min_S: float, default=min_S</span>
<span class="sd">            constant small value added in case of log2_ratio estimation. (DEPRECATED)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing it only creates the following attributes</span>
<span class="sd">        delta_S: np.ndarray</span>
<span class="sd">            The variation in gene expression</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">assumption</span> <span class="o">==</span> <span class="s2">&quot;constant_velocity&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;difference&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delta_S</span> <span class="o">=</span> <span class="n">delta_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Kind </span><span class="si">{kind}</span><span class="s2"> is not implemented for assumption </span><span class="si">{assumption}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">assumption</span> <span class="o">==</span> <span class="s2">&quot;constant_unspliced&quot;</span><span class="p">:</span>
            <span class="c1"># Ux_sz = self.Ux_sz - offset; Ux_sz[Ux_sz&lt;0] = 0</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;difference&quot;</span><span class="p">:</span>  <span class="c1"># maybe I should say ratio see below</span>
                <span class="n">Ux_szo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="n">Ux_szo</span><span class="p">[</span><span class="n">Ux_szo</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">egt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">gammas</span> <span class="o">*</span> <span class="n">delta_t</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delta_S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span> <span class="o">*</span> <span class="n">egt</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">egt</span><span class="p">)</span> <span class="o">*</span> <span class="n">Ux_szo</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">gammas</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Kind </span><span class="si">{kind}</span><span class="s2"> is not implemented for assumption </span><span class="si">{assumption}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Assumption </span><span class="si">{assumption}</span><span class="s2"> is not implemented&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.extrapolate_cell_at_t"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.extrapolate_cell_at_t">[docs]</a>    <span class="k">def</span> <span class="nf">extrapolate_cell_at_t</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">clip</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Extrapolate the gene expression profile for each cell after delta_t</span>
<span class="sd">        </span>
<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        delta_t: float, default=1</span>
<span class="sd">            the time step considered for the extrapolation</span>
<span class="sd">        clip: bool, default=True</span>
<span class="sd">            If True negative values are clipped to zero</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but it creates the attributes:</span>
<span class="sd">        Sx_sz_t: np.ndarray</span>
<span class="sd">            the extrapolated expression profile</span>
<span class="sd">        used_delta_t: float</span>
<span class="sd">            stores delta_t for future usage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_S_for_pred</span> <span class="o">==</span> <span class="s2">&quot;Sx_sz&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span> <span class="o">+</span> <span class="n">delta_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_S</span>
            <span class="k">if</span> <span class="n">clip</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz_t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">used_delta_t</span> <span class="o">=</span> <span class="n">delta_t</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_S_for_pred</span> <span class="o">==</span> <span class="s2">&quot;Sx&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sx_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">+</span> <span class="n">delta_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_S</span>
            <span class="k">if</span> <span class="n">clip</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Sx_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx_t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">used_delta_t</span> <span class="o">=</span> <span class="n">delta_t</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;not implemented for other situations other than Sx or Sx_sz&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.perform_TSNE"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.perform_TSNE">[docs]</a>    <span class="k">def</span> <span class="nf">perform_TSNE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_dims</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">perplexity</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">initial_pos</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">theta</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">n_pca_dim</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Perform TSNE on the PCA using barnes hut approximation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Perform TSNE</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Running bhtsne&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">initial_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">initial_pos</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span>
        <span class="n">bh_tsne</span> <span class="o">=</span> <span class="n">TSNE</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_dims</span><span class="p">,</span> <span class="n">perplexity</span><span class="o">=</span><span class="n">perplexity</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="n">initial_pos</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ts</span> <span class="o">=</span> <span class="n">bh_tsne</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcs</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n_pca_dim</span><span class="p">])</span></div>

<div class="viewcode-block" id="VelocytoLoom.estimate_transition_prob"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.estimate_transition_prob">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_transition_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;Sx_sz&quot;</span><span class="p">,</span> <span class="n">embed</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;ts&quot;</span><span class="p">,</span> <span class="n">transform</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;sqrt&quot;</span><span class="p">,</span>
                                 <span class="n">ndims</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">psc</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
                                 <span class="n">knn_random</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sampled_fraction</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">delta_kind</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;clipped&quot;</span><span class="p">,</span>
                                 <span class="n">sampling_pobs</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span> <span class="n">max_dist_embed</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">random_seed</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">15071990</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Use correlation to estimate transition probabilities for every cells to its embedding neighborhood</span>
<span class="sd">        </span>
<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        hidim: str, dafault=&quot;Sx_sz&quot;</span>
<span class="sd">            The name of the attribute containing the high dimensional space. It will be retrieved as getattr(self, hidim)</span>
<span class="sd">            The updated vector at time t is assumed to be getattr(self, hidim + &quot;_t&quot;)</span>
<span class="sd">            Appending .T to the string will transpose the matrix (usefull in case we want to use S or Sx)</span>
<span class="sd">        embed: str, dafault=&quot;ts&quot;</span>
<span class="sd">            The name of the attribute containing the embedding. It will be retrieved as getattr(self, embed)</span>
<span class="sd">        transform: str, default=&quot;sqrt&quot;</span>
<span class="sd">            The transformation that is applies on the high dimensional space.</span>
<span class="sd">            If None the raw data will be used</span>
<span class="sd">        ndims: int, default=None</span>
<span class="sd">            The number of dimensions of the high dimensional space to work with. If None all will be considered</span>
<span class="sd">            It makes sense only when using principal components</span>
<span class="sd">        n_neighbors: int, default=None</span>
<span class="sd">            The number of neighbours to take into account</span>
<span class="sd">        psc: float, default=1</span>
<span class="sd">            pseudocount added in variance normalizing tranform</span>
<span class="sd">        knn_random: bool, default=True</span>
<span class="sd">            whether to random sample the neighboroods to speedup calculation</span>
<span class="sd">        delta_kind: clipped, unclipped, residual</span>
<span class="sd">            whether to clip the delta</span>
<span class="sd">        sampling_pobs: Tuple, default=(0.5, 1)</span>
<span class="sd">        max_dist_embed: float, default=None</span>
<span class="sd">            CURRENTLY NOT USED</span>
<span class="sd">            The maximum distance allowed</span>
<span class="sd">            If None it will be set to 0.25 * average_distance_two_points_taken_at_random</span>
<span class="sd">        n_jobs: int, default=4</span>
<span class="sd">            number of jobs to calkulate knn</span>
<span class="sd">            this only applies to the knn search, by default half of the cps will be used for the actual correlation computation</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">n_neighbors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_neighbors</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">5</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">knn_random</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">corr_calc</span> <span class="o">=</span> <span class="s2">&quot;knn_random&quot;</span>
            <span class="k">if</span> <span class="s2">&quot;pcs&quot;</span> <span class="ow">in</span> <span class="n">hidim</span><span class="p">:</span>  <span class="c1"># sic</span>
                <span class="n">hi_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
                <span class="n">hi_dim_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span> <span class="o">+</span> <span class="s2">&quot;_t&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hi_dim</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">delta_kind</span> <span class="o">==</span> <span class="s2">&quot;clipped&quot;</span><span class="p">:</span>
                    <span class="n">hi_dim_t</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span> <span class="o">+</span> <span class="s2">&quot;_t&quot;</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">delta_kind</span> <span class="o">==</span> <span class="s2">&quot;unclipped&quot;</span><span class="p">:</span>
                    <span class="n">hi_dim_t</span> <span class="o">=</span> <span class="n">hi_dim</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">used_delta_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_S</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">delta_kind</span> <span class="o">==</span> <span class="s2">&quot;residual&quot;</span><span class="p">:</span>
                    <span class="n">hi_dim_t</span> <span class="o">=</span> <span class="n">hi_dim</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_S</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span>
                
            <span class="n">embedding</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embed</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span> <span class="o">=</span> <span class="n">embedding</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Calculate KNN in the embedding space&quot;</span><span class="p">)</span>
            <span class="n">nn</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">embedding_knn</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors_graph</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;connectivity&quot;</span><span class="p">)</span>

            <span class="c1"># Pick random neighbours and prune the rest</span>
            <span class="n">neigh_ixs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding_knn</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">sampling_pobs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sampling_pobs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">neigh_ixs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">/</span> <span class="n">p</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="c1"># NOTE: problem of API consistency because the random.choice can pick the diagonal value (or not)</span>
            <span class="c1"># resulting self.corrcoeff with different number of nonzero entry per row.</span>
            <span class="c1"># Not updated yet not to break previous analyses</span>
            <span class="c1"># Fix is substituting below `neigh_ixs.shape[1]` with `np.arange(1,neigh_ixs.shape[1]-1)`</span>
            <span class="n">sampling_ixs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">neigh_ixs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                      <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">sampled_fraction</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),),</span>
                                                      <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                      <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">neigh_ixs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampling_ixs</span> <span class="o">=</span> <span class="n">sampling_ixs</span>
            <span class="n">neigh_ixs</span> <span class="o">=</span> <span class="n">neigh_ixs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">neigh_ixs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">sampling_ixs</span><span class="p">]</span>
            <span class="n">nonzero</span> <span class="o">=</span> <span class="n">neigh_ixs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">neigh_ixs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">embedding_knn</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nonzero</span><span class="p">),</span>
                                                    <span class="n">neigh_ixs</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                                    <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nonzero</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">neigh_ixs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
                                                   <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">neigh_ixs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                          <span class="n">neigh_ixs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Correlation Calculation &#39;</span><span class="si">{self.corr_calc}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span><span class="p">:</span>
                <span class="n">delta_hi_dim</span> <span class="o">=</span> <span class="n">hi_dim_t</span> <span class="o">-</span> <span class="n">hi_dim</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span> <span class="o">=</span> <span class="n">colDeltaCorLog10partial</span><span class="p">(</span><span class="n">hi_dim</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">delta_hi_dim</span><span class="p">)</span> <span class="o">+</span> <span class="n">psc</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">delta_hi_dim</span><span class="p">),</span> <span class="n">neigh_ixs</span><span class="p">,</span> <span class="n">psc</span><span class="o">=</span><span class="n">psc</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;logratio&quot;</span><span class="p">:</span>
                <span class="n">log2hidim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">hi_dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">delta_hi_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">hi_dim_t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">log2hidim</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span> <span class="o">=</span> <span class="n">colDeltaCorpartial</span><span class="p">(</span><span class="n">log2hidim</span><span class="p">,</span> <span class="n">delta_hi_dim</span><span class="p">,</span> <span class="n">neigh_ixs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span> <span class="o">=</span> <span class="n">colDeltaCorpartial</span><span class="p">(</span><span class="n">hi_dim</span><span class="p">,</span> <span class="n">hi_dim_t</span> <span class="o">-</span> <span class="n">hi_dim</span><span class="p">,</span> <span class="n">neigh_ixs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;sqrt&quot;</span><span class="p">:</span>
                <span class="n">delta_hi_dim</span> <span class="o">=</span> <span class="n">hi_dim_t</span> <span class="o">-</span> <span class="n">hi_dim</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span> <span class="o">=</span> <span class="n">colDeltaCorSqrtpartial</span><span class="p">(</span><span class="n">hi_dim</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">delta_hi_dim</span><span class="p">)</span> <span class="o">+</span> <span class="n">psc</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">delta_hi_dim</span><span class="p">),</span> <span class="n">neigh_ixs</span><span class="p">,</span> <span class="n">psc</span><span class="o">=</span><span class="n">psc</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;tranform=</span><span class="si">{transform}</span><span class="s2"> is not a valid parameter&quot;</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Nans encountered in corrcoef and corrected to 1s. If not identical cells were present it is probably a small isolated cluster converging after imputation.&quot;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Done Correlation Calculation&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">corr_calc</span> <span class="o">=</span> <span class="s2">&quot;full&quot;</span>
            <span class="k">if</span> <span class="s2">&quot;pcs&quot;</span> <span class="ow">in</span> <span class="n">hidim</span><span class="p">:</span>  <span class="c1"># sic</span>
                <span class="n">hi_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
                <span class="n">hi_dim_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span> <span class="o">+</span> <span class="s2">&quot;_t&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hi_dim</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span>
                <span class="n">hi_dim_t</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span> <span class="o">+</span> <span class="s2">&quot;_t&quot;</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span>
                
            <span class="n">embedding</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embed</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span> <span class="o">=</span> <span class="n">embedding</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Calculate KNN in the embedding space&quot;</span><span class="p">)</span>
            <span class="n">nn</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">embedding_knn</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors_graph</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;connectivity&quot;</span><span class="p">)</span>
            
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Correlation Calculation &#39;full&#39;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span><span class="p">:</span>
                <span class="n">delta_hi_dim</span> <span class="o">=</span> <span class="n">hi_dim_t</span> <span class="o">-</span> <span class="n">hi_dim</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span> <span class="o">=</span> <span class="n">colDeltaCorLog10</span><span class="p">(</span><span class="n">hi_dim</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">delta_hi_dim</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">delta_hi_dim</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;logratio&quot;</span><span class="p">:</span>
                <span class="n">log2hidim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">hi_dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">delta_hi_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">hi_dim_t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">log2hidim</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span> <span class="o">=</span> <span class="n">colDeltaCor</span><span class="p">(</span><span class="n">log2hidim</span><span class="p">,</span> <span class="n">delta_hi_dim</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span> <span class="o">=</span> <span class="n">colDeltaCor</span><span class="p">(</span><span class="n">hi_dim</span><span class="p">,</span> <span class="n">hi_dim_t</span> <span class="o">-</span> <span class="n">hi_dim</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;sqrt&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;tranform=</span><span class="si">{transform}</span><span class="s2"> is not implemented with corr_calc=&#39;full&#39;&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;rank&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;tranform=</span><span class="si">{transform}</span><span class="s2"> is not implemented with corr_calc=&#39;full&#39;&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;tranform=</span><span class="si">{transform}</span><span class="s2"> is not a valid parameter&quot;</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.calculate_embedding_shift"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.calculate_embedding_shift">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_embedding_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma_corr</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Use the transition probability to project the velocity direction on the embedding</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        sigma_corr: float, default=0.05</span>
<span class="sd">            the kernel scaling</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but it creates the following attributes:</span>
<span class="sd">        transition_prob: np.ndarray</span>
<span class="sd">            the transition probability calculated using the exponential kernel on the correlation coefficient</span>
<span class="sd">        delta_embedding: np.ndarray</span>
<span class="sd">            The resulting vector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Kernel evaluation</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Calculate transition probability&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_calc</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_calc</span> <span class="o">==</span> <span class="s2">&quot;knn_random&quot;</span><span class="p">:</span>
            <span class="c1"># NOTE maybe sparse matrix here are slower than dense</span>
            <span class="c1"># NOTE if knn_random this could be made much faster either using sparse matrix or neigh_ixs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transition_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span> <span class="o">/</span> <span class="n">sigma_corr</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding_knn</span><span class="o">.</span><span class="n">A</span>  <span class="c1"># naive</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transition_prob</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_prob</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>

            <span class="n">unitary_vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span>  <span class="c1"># shape (2,ncells,ncells)</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">unitary_vectors</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">unitary_vectors</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># divide by L2</span>
                <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">unitary_vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># fix nans</span>
                <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">unitary_vectors</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta_embedding</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transition_prob</span> <span class="o">*</span> <span class="n">unitary_vectors</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta_embedding</span> <span class="o">-=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding_knn</span><span class="o">.</span><span class="n">A</span> <span class="o">*</span> <span class="n">unitary_vectors</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding_knn</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">T</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta_embedding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_embedding</span><span class="o">.</span><span class="n">T</span>
            <span class="c1"># sparse matrix version of the same code</span>
            <span class="c1"># self.transition_prob = np.expm1(sparse.csr_matrix.multiply(self.embedding_knn, self.corrcoef) / sigma_corr) + self.embedding_knn[0,:].sum()</span>
            <span class="c1"># self.transition_prob.multiply(1. / sparse.csr_matrix.sum(mknn, axis=1))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># NOTE should implement a version with cython</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Weird value self.corr_calc=</span><span class="si">{self.corr_calc}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.calculate_grid_arrows"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.calculate_grid_arrows">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_grid_arrows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embed</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;embedding&quot;</span><span class="p">,</span> <span class="n">smooth</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">steps</span><span class="p">:</span> <span class="n">Tuple</span><span class="o">=</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span>
                              <span class="n">n_neighbors</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calculate the velocity using a points on a regular grid and a gaussian kernel</span>

<span class="sd">        Note: the function should work also for n-dimensional grid</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        embed: str, default=embedding</span>
<span class="sd">            The name of the attribute containing the embedding. It will be retrieved as getattr(self, embed)</span>
<span class="sd">            The updated vector at time t is assumed to be getattr(self, embed + &#39;_t&#39;)</span>
<span class="sd">            Or the difference vector is getattr(self, &#39;delta&#39; + &#39;_&#39; + embed)</span>
<span class="sd">        smooth: float, smooth=0.5</span>
<span class="sd">            Higher value correspond to taking in consideration further points</span>
<span class="sd">            the standard deviation of the gaussian kernel is smooth * stepsize</span>
<span class="sd">        steps: tuple, default</span>
<span class="sd">            the number of steps in the grid for each axis</span>
<span class="sd">        n_neighbors:</span>
<span class="sd">            number of neighbors to use in the calculation, bigger number should not change too much the results..</span>
<span class="sd">            ...as soon as smooth is small</span>
<span class="sd">            Higher value correspond to slower execution time</span>
<span class="sd">        n_jobs:</span>
<span class="sd">            number of processes for parallel computing</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but it sets the attributes:</span>
<span class="sd">        flow_embedding: np.ndarray</span>
<span class="sd">            the coordinates of the embedding</span>
<span class="sd">        flow_grid: np.ndarray</span>
<span class="sd">            the gridpoints</span>
<span class="sd">        flow: np.ndarray</span>
<span class="sd">            vector field coordinates</span>
<span class="sd">        flow_magnitude: np.ndarray</span>
<span class="sd">            magnitude of each vector on the grid</span>
<span class="sd">        total_p_mass: np.ndarray</span>
<span class="sd">            density at each point of the grid</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">embedding</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embed</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embed</span> <span class="o">+</span> <span class="s2">&quot;_t&quot;</span><span class="p">):</span>
            <span class="n">delta_embedding</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embed</span> <span class="o">+</span> <span class="s2">&quot;_t&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="n">embedding</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;delta_&quot;</span> <span class="o">+</span> <span class="n">embed</span><span class="p">):</span>
            <span class="n">delta_embedding</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;delta_&quot;</span> <span class="o">+</span> <span class="n">embed</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;This embedding does not have a delta_* or a *_t&quot;</span><span class="p">)</span>
        <span class="c1"># Prepare the grid</span>
        <span class="n">grs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dim_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">m</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">embedding</span><span class="p">[:,</span> <span class="n">dim_i</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">embedding</span><span class="p">[:,</span> <span class="n">dim_i</span><span class="p">])</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mf">0.025</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">M</span> <span class="o">+</span> <span class="mf">0.025</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">gr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">steps</span><span class="p">[</span><span class="n">dim_i</span><span class="p">])</span>
            <span class="n">grs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gr</span><span class="p">)</span>
            
        <span class="n">meshes_tuple</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">grs</span><span class="p">)</span>
        <span class="n">gridpoints_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">flat</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">meshes_tuple</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="n">nn</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
        <span class="n">dists</span><span class="p">,</span> <span class="n">neighs</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">gridpoints_coordinates</span><span class="p">)</span>
        
        <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([(</span><span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grs</span><span class="p">])</span>
        <span class="c1"># isotropic gaussian kernel</span>
        <span class="n">gaussian_w</span> <span class="o">=</span> <span class="n">normal</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">smooth</span> <span class="o">*</span> <span class="n">std</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">dists</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_p_mass</span> <span class="o">=</span> <span class="n">gaussian_w</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">UZ</span> <span class="o">=</span> <span class="p">(</span><span class="n">delta_embedding</span><span class="p">[</span><span class="n">neighs</span><span class="p">]</span> <span class="o">*</span> <span class="n">gaussian_w</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_p_mass</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>  <span class="c1"># weighed average</span>
        <span class="n">magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">UZ</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Assign attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow_embedding</span> <span class="o">=</span> <span class="n">embedding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow_grid</span> <span class="o">=</span> <span class="n">gridpoints_coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow</span> <span class="o">=</span> <span class="n">UZ</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow_norm</span> <span class="o">=</span> <span class="n">UZ</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">magnitude</span><span class="p">,</span> <span class="mf">99.5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow_norm_magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.prepare_markov"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.prepare_markov">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_markov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma_D</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sigma_W</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;forward&quot;</span><span class="p">,</span> <span class="n">cells_ixs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Prepare a transition probability for Markov process</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        sigma_D: float</span>
<span class="sd">            the standard deviation used on the locality-limiting component</span>
<span class="sd">        sigma_W: float</span>
<span class="sd">            the standard deviation used on the noise component</span>
<span class="sd">        direction: str, default=&quot;backwards&quot;</span>
<span class="sd">            whether to diffuse forward of backwards</span>
<span class="sd">        cells_ixs: np.ndarray, default=None</span>
<span class="sd">            Cells to use, if None all the cells will be considered.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but it creates the following attributes:</span>
<span class="sd">        tr: np.ndarray</span>
<span class="sd">            the transition probability matrix</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cells_ixs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cells_ixs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transition_prob</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># NOTE: This implementation is not speed optimized to improve the speed of the implementation:</span>
        <span class="c1"># - the C/Fortran contiguity of the transition matrix should be taken into account</span>
        <span class="c1"># - a knn implementation would reduce computation</span>
        <span class="c1"># - should avoid transformation to and from dense-sparse formats</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;forward&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transition_prob</span><span class="p">[</span><span class="n">cells_ixs</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">cells_ixs</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;backwards&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">transition_prob</span><span class="p">[</span><span class="n">cells_ixs</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">cells_ixs</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{direction}</span><span class="s2"> is not an implemented direction&quot;</span><span class="p">)</span>
        <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">squareform</span><span class="p">(</span><span class="n">pdist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">cells_ixs</span><span class="p">,</span> <span class="p">:]))</span>
        <span class="n">K_D</span> <span class="o">=</span> <span class="n">gaussian_kernel</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma_D</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr</span> <span class="o">*</span> <span class="n">K_D</span>
        <span class="c1"># Fill diagonal with max or the row and sum=1 normalize</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
       
        <span class="n">K_W</span> <span class="o">=</span> <span class="n">gaussian_kernel</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma_W</span><span class="p">)</span>
        <span class="n">K_W</span> <span class="o">=</span> <span class="n">K_W</span> <span class="o">/</span> <span class="n">K_W</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tr</span> <span class="o">=</span> <span class="mf">0.8</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr</span> <span class="o">+</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="n">K_W</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tr</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tr</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.run_markov"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.run_markov">[docs]</a>    <span class="k">def</span> <span class="nf">run_markov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starting_p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">2500</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;time_evolution&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Run a Markov process</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        starting_p: np.ndarray, default=None</span>
<span class="sd">            sepcifies the starting density</span>
<span class="sd">            if None is passed an array of 1/self.tr.shape[0] will be created</span>
<span class="sd">        n_steps: np.ndarray, default=2500</span>
<span class="sd">            Numbers of steps to be performed</span>
<span class="sd">        mode: str, default=&quot;time_evolution&quot;</span>
<span class="sd">            this argument is passed to the Diffusion.diffuse call</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but it creates the attribute:</span>
<span class="sd">        diffused: np.ndarray</span>
<span class="sd">            The probability to be found at any of the states</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">starting_p</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">starting_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">diffusor</span> <span class="o">=</span> <span class="n">Diffusion</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diffused</span> <span class="o">=</span> <span class="n">diffusor</span><span class="o">.</span><span class="n">diffuse</span><span class="p">(</span><span class="n">starting_p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="n">n_steps</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="VelocytoLoom.default_filter_and_norm"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.default_filter_and_norm">[docs]</a>    <span class="k">def</span> <span class="nf">default_filter_and_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_expr_counts</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_cells_express</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_avg_U</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_avg_S</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Useful function to get started with velocyto: it performs initial filtering and feature selection, it uses some heuristics to determine the thresholds, results might be suboptimal.</span>

<span class="sd">        See `the analysis quick start guide &lt;http://velocyto.org/velocyto.py/tutorial/analysis.html&gt;`_ for further info.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        min_expr_counts: int, default=None</span>
<span class="sd">            filtering condition: the minimum spliced counts</span>
<span class="sd">        min_cells_express: int, default=None</span>
<span class="sd">            filtering condition: the minimum number of cells expressing the gene</span>
<span class="sd">        N: int, default=None</span>
<span class="sd">            number of genes selected by the feature selection procedure</span>
<span class="sd">        min_avg_U: float, default=None</span>
<span class="sd">            if cluster have been specified beforehand (using the function set_clusters) then this is the minimum average unspliced molecules per cluster</span>
<span class="sd">        min_avg_S: float, default=None</span>
<span class="sd">            if cluster have been specified beforehand (using the function set_clusters) then this is the minimum average spliced molecules per cluster</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">min_expr_counts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">min_expr_counts</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">2.25e-3</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">min_cells_express</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">min_cells_express</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.5e-3</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="nb">min</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mf">0.0008</span><span class="p">,</span> <span class="mi">5000</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">min_avg_U</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">min_avg_U</span> <span class="o">=</span> <span class="mf">0.01</span>
        <span class="k">if</span> <span class="n">min_avg_S</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">min_avg_S</span> <span class="o">=</span> <span class="mf">0.08</span>

        <span class="c1"># This is called just to compute the initial cell size, normalized value will be recalculated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">score_detection_levels</span><span class="p">(</span><span class="n">min_expr_counts</span><span class="o">=</span><span class="n">min_expr_counts</span><span class="p">,</span> <span class="n">min_cells_express</span><span class="o">=</span><span class="n">min_cells_express</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_genes</span><span class="p">(</span><span class="n">by_detection_levels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">score_cv_vs_mean</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">max_expr_avg</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_genes</span><span class="p">(</span><span class="n">by_cv_vs_mean</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">score_detection_levels</span><span class="p">(</span><span class="n">min_expr_counts</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">min_cells_express</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                    <span class="n">min_expr_counts_U</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">min_expr_counts</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                    <span class="n">min_cells_express_U</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">min_cells_express</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;cluster_labels&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">score_cluster_expression</span><span class="p">(</span><span class="n">min_avg_U</span><span class="o">=</span><span class="n">min_avg_U</span><span class="p">,</span> <span class="n">min_avg_S</span><span class="o">=</span><span class="n">min_avg_S</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_genes</span><span class="p">(</span><span class="n">by_detection_levels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">by_cluster_expression</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_genes</span><span class="p">(</span><span class="n">by_detection_levels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalize_by_total</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adjust_totS_totU</span><span class="p">(</span><span class="n">normalize_total</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.default_fit_preparation"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.default_fit_preparation">[docs]</a>    <span class="k">def</span> <span class="nf">default_fit_preparation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_comps</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Useful function to get started with velocyto: it performs PCA and kNN smoothing, it uses some heuristics to determine the parameters, results might be suboptimal.</span>

<span class="sd">        See `the analysis quick start guide &lt;http://velocyto.org/velocyto.py/tutorial/analysis.html&gt;`_ for further info.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        k: int, default=None</span>
<span class="sd">            k in k-NearestNeighbours smoothing</span>
<span class="sd">        n_comps: int, default=None</span>
<span class="sd">            numbed of components in pca</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perform_PCA</span><span class="p">()</span>
        <span class="c1"># Choose the number of components to use for the kNN graph</span>
        <span class="k">if</span> <span class="n">n_comps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_comps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">0.002</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.02</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_imputation</span><span class="p">(</span><span class="n">n_pca_dims</span><span class="o">=</span><span class="n">n_comps</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">balanced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">b_sight</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
                            <span class="n">b_maxl</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalize_median</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_plot_phase_portrait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gene</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">gs_i</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Plot spliced-unspliced scatterplot resembling phase portrait</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">gs_i</span><span class="p">)</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="p">[</span><span class="s2">&quot;Gene&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">gene</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">scatter_viz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:],</span> <span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">colorandum</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">gene</span><span class="p">)</span>
        <span class="n">xnew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xnew</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gammas</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">*</span> <span class="n">xnew</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="VelocytoLoom.plot_phase_portraits"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.plot_phase_portraits">[docs]</a>    <span class="k">def</span> <span class="nf">plot_phase_portraits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">genes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Plot spliced-unspliced scatterplots resembling phase portraits</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        genes: List[str]</span>
<span class="sd">            A list of gene symbols.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">genes</span><span class="p">)</span>
        <span class="n">sqrtn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="n">gs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="n">sqrtn</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">sqrtn</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">genes</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_plot_phase_portrait</span><span class="p">(</span><span class="n">gn</span><span class="p">,</span> <span class="n">gs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span></div>
    
<div class="viewcode-block" id="VelocytoLoom.plot_grid_arrows"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.plot_grid_arrows">[docs]</a>    <span class="k">def</span> <span class="nf">plot_grid_arrows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quiver_scale</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_mass</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">min_magnitude</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">scatter_kwargs_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">plot_dots</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">quiver_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Plots vector field averaging velocity vectors on a grid</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        quiver_scale: float, dafault=None</span>
<span class="sd">            Rescaling factor applied to the arrow field to enhance visibility</span>
<span class="sd">        min_mass: float, default=1</span>
<span class="sd">            the minimum density around a grid point for it to be considered</span>
<span class="sd">        min_magnitude: float, default=None</span>
<span class="sd">            the minimum magnitude of the velocity to plot</span>
<span class="sd">        scatter_kwargs_dict: dict, default=None</span>
<span class="sd">            the keyword arguments to pass to scatter</span>
<span class="sd">        plot_dots: bool, default= True</span>
<span class="sd">            whether to plot the cell symbols</span>
<span class="sd">        **quiver_kwargs: dict</span>
<span class="sd">            keyword arguments to pass to quiver</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># plt.figure(figsize=(10, 10))</span>
        <span class="n">scatter_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;zorder&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span> <span class="s2">&quot;lw&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">colorandum</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">scatter_kwargs_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scatter_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">scatter_kwargs_dict</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_embedding</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_embedding</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">scatter_dict</span><span class="p">)</span>
        
        <span class="n">mass_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_p_mass</span> <span class="o">&lt;</span> <span class="n">min_mass</span>
        <span class="k">if</span> <span class="n">min_magnitude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">XY</span><span class="p">,</span> <span class="n">UV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_grid</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">plot_dots</span><span class="p">:</span>
                <span class="n">UV</span> <span class="o">=</span> <span class="n">UV</span><span class="p">[</span><span class="o">~</span><span class="n">mass_filter</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">XY</span> <span class="o">=</span> <span class="n">XY</span><span class="p">[</span><span class="o">~</span><span class="n">mass_filter</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">UV</span><span class="p">[</span><span class="n">mass_filter</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">XY</span><span class="p">,</span> <span class="n">UV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_grid</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_norm</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">plot_dots</span><span class="p">:</span>
                <span class="n">UV</span> <span class="o">=</span> <span class="n">UV</span><span class="p">[</span><span class="o">~</span><span class="p">(</span><span class="n">mass_filter</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_norm_magnitude</span> <span class="o">&lt;</span> <span class="n">min_magnitude</span><span class="p">)),</span> <span class="p">:]</span>
                <span class="n">XY</span> <span class="o">=</span> <span class="n">XY</span><span class="p">[</span><span class="o">~</span><span class="p">(</span><span class="n">mass_filter</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_norm_magnitude</span> <span class="o">&lt;</span> <span class="n">min_magnitude</span><span class="p">)),</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">UV</span><span class="p">[</span><span class="n">mass_filter</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_norm_magnitude</span> <span class="o">&lt;</span> <span class="n">min_magnitude</span><span class="p">),</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">XY</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">XY</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">UV</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">UV</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                   <span class="n">scale</span><span class="o">=</span><span class="n">quiver_scale</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span> <span class="o">**</span><span class="n">quiver_kwargs</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.plot_arrows_embedding"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.plot_arrows_embedding">[docs]</a>    <span class="k">def</span> <span class="nf">plot_arrows_embedding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">choice</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">plot_scatter</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">color_arrow</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;cluster&quot;</span><span class="p">,</span> <span class="n">quiver_scale</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">new_fig</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">quiver_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Plots the results of the arrows_from_hidim_to_embedding</span>
<span class="sd">        </span>
<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        choice: int, default = 1000</span>
<span class="sd">            the number of cells to randomly pick to plot the arrows</span>
<span class="sd">        plot_scatter: bool, default = False</span>
<span class="sd">            whether to plot the points</span>
<span class="sd">        color_arrow: str, default = &quot;cluster</span>
<span class="sd">            the color of the arrows, if &quot;cluster&quot; the arrows are colored the same as the cluster</span>
<span class="sd">        epsilon: float, default = None</span>
<span class="sd">            the minimal size of the arrow that can be plotted before it becomes invisible</span>
<span class="sd">        quiver_scale: float</span>
<span class="sd">            scale argument passed to the matplotlib quiver function</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing, just plots the tsne with arrows</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_fig</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">14</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">plot_scatter</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">colorandum</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        
        <span class="n">ix_choice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">choice</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">color_arrow</span> <span class="o">==</span> <span class="s2">&quot;cluster&quot;</span><span class="p">:</span>
            <span class="n">colorandum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colorandum</span><span class="p">[</span><span class="n">ix_choice</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">colorandum</span> <span class="o">=</span> <span class="n">color_arrow</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">ix_choice</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">ix_choice</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">delta_embedding</span><span class="p">[</span><span class="n">ix_choice</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_embedding</span><span class="p">[</span><span class="n">ix_choice</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                   <span class="n">color</span><span class="o">=</span><span class="n">colorandum</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">quiver_scale</span><span class="p">,</span> <span class="o">**</span><span class="n">quiver_kwargs</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="VelocytoLoom.plot_cell_transitions"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.plot_cell_transitions">[docs]</a>    <span class="k">def</span> <span class="nf">plot_cell_transitions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_ix</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">alpha_neigh</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
                              <span class="n">cmap_name</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;RdBu_r&quot;</span><span class="p">,</span> <span class="n">plot_arrow</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">mark_cell</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">head_width</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Plot the probability of a cell to transition to any other cell</span>

<span class="sd">        This function is untested</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">cmap_name</span><span class="p">)</span>
        <span class="n">colorandum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">colorandum</span> <span class="o">*=</span> <span class="mf">0.3</span>
        <span class="n">colorandum</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">c</span><span class="o">=</span><span class="n">colorandum</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mark_cell</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">cell_ix</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">cell_ix</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plot_arrow</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">cell_ix</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">cell_ix</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">delta_embedding</span><span class="p">[</span><span class="n">cell_ix</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_embedding</span><span class="p">[</span><span class="n">cell_ix</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                      <span class="n">head_width</span><span class="o">=</span><span class="n">head_width</span><span class="p">,</span> <span class="n">length_includes_head</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="VelocytoLoom.plot_velocity_as_color"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.plot_velocity_as_color">[docs]</a>    <span class="k">def</span> <span class="nf">plot_velocity_as_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gene_name</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">RdBu_r</span><span class="p">,</span>
                               <span class="n">gs</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">which_tsne</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;ts&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Plot velocity as color on the Tsne embedding</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        gene_name: str</span>
<span class="sd">            The name of the gene, should be present in self.S</span>
<span class="sd">        cmap: maplotlib.cm.Colormap, dafault=maplotlib.cm.RdBu_r</span>
<span class="sd">            Colormap to use, devergent are better, RdBu_r is default</span>
<span class="sd">            Notice that 0 will be always set as the center of the colormap. (e.g. white in RdBu_r)</span>
<span class="sd">        gs: Gridspec subplot</span>
<span class="sd">            Gridspec subplot to plot on.</span>
<span class="sd">        which_tsne: str, default=&quot;ts&quot;</span>
<span class="sd">            the name of the attributed where the desired embedding is stored</span>
<span class="sd">        **kwargs: dict</span>
<span class="sd">            other keywords arguments will be passed to the plt.scatter call</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="p">[</span><span class="s2">&quot;Gene&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">gene_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">kwarg_plot</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s2">&quot;edgecolor&quot;</span><span class="p">:</span> <span class="s2">&quot;0.8&quot;</span><span class="p">,</span> <span class="s2">&quot;lw&quot;</span><span class="p">:</span> <span class="mf">0.15</span><span class="p">}</span>
        <span class="n">kwarg_plot</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">)</span>
    
        <span class="n">tsne</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_tsne</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_S_for_pred</span> <span class="o">==</span> <span class="s2">&quot;Sx_sz&quot;</span><span class="p">:</span>
            <span class="n">tmp_colorandum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz_t</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp_colorandum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx_t</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tmp_colorandum</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.00005</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>  <span class="c1"># If S vs U scatterplot it is flat</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;S vs U scatterplot it is flat&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">tmp_colorandum</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">99</span><span class="p">])))</span>  <span class="c1"># upper and lowe limit / saturation</span>
        <span class="n">tmp_colorandum</span> <span class="o">=</span> <span class="n">tmp_colorandum</span> <span class="o">+</span> <span class="n">limit</span>  <span class="c1"># that is: tmp_colorandum - (-limit)</span>
        <span class="n">tmp_colorandum</span> <span class="o">=</span> <span class="n">tmp_colorandum</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">limit</span><span class="p">)</span>  <span class="c1"># that is: tmp_colorandum / (limit - (-limit))</span>
        <span class="n">tmp_colorandum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">tmp_colorandum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">scatter_viz</span><span class="p">(</span><span class="n">tsne</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">tsne</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">c</span><span class="o">=</span><span class="n">cmap</span><span class="p">(</span><span class="n">tmp_colorandum</span><span class="p">),</span> <span class="o">**</span><span class="n">kwarg_plot</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{gene_name}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.plot_expression_as_color"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.plot_expression_as_color">[docs]</a>    <span class="k">def</span> <span class="nf">plot_expression_as_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gene_name</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">imputed</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">cmap</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Greens</span><span class="p">,</span>
                                 <span class="n">gs</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">which_tsne</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;ts&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Plot expression as color on the Tsne embedding</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        gene_name: str</span>
<span class="sd">            The name of the gene, should be present in self.S</span>
<span class="sd">        imputed: bool, default=True</span>
<span class="sd">            whether to plot the smoothed or the raw data</span>
<span class="sd">        cmap: maplotlib.cm.Colormap, dafault=maplotlib.cm.Greens</span>
<span class="sd">            Colormap to use.</span>
<span class="sd">        gs: Gridspec subplot</span>
<span class="sd">            Gridspec subplot to plot on.</span>
<span class="sd">        which_tsne: str, default=&quot;ts&quot;</span>
<span class="sd">            the name of the attributed where the desired embedding is stored</span>
<span class="sd">        **kwargs: dict</span>
<span class="sd">            other keywords arguments will be passed to the plt.scatter call</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="p">[</span><span class="s2">&quot;Gene&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">gene_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">kwarg_plot</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s2">&quot;edgecolor&quot;</span><span class="p">:</span> <span class="s2">&quot;0.8&quot;</span><span class="p">,</span> <span class="s2">&quot;lw&quot;</span><span class="p">:</span> <span class="mf">0.15</span><span class="p">}</span>
        <span class="n">kwarg_plot</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">)</span>
    
        <span class="n">tsne</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_tsne</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">imputed</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_S_for_pred</span> <span class="o">==</span> <span class="s2">&quot;Sx_sz&quot;</span><span class="p">:</span>
                <span class="n">tmp_colorandum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmp_colorandum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp_colorandum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span>
            
        <span class="n">tmp_colorandum</span> <span class="o">=</span> <span class="n">tmp_colorandum</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">tmp_colorandum</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
        <span class="c1"># tmp_colorandum = np.log2(tmp_colorandum+1)</span>
        <span class="n">tmp_colorandum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">tmp_colorandum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">scatter_viz</span><span class="p">(</span><span class="n">tsne</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">tsne</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">c</span><span class="o">=</span><span class="n">cmap</span><span class="p">(</span><span class="n">tmp_colorandum</span><span class="p">),</span> <span class="o">**</span><span class="n">kwarg_plot</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{gene_name}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.reload_raw"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.reload_raw">[docs]</a>    <span class="k">def</span> <span class="nf">reload_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">substitute</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Reload raw data as it was before filtering steps</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        substitute: bool=False</span>
<span class="sd">            if True `S, U, A, ca, ra` will be all overwritten</span>
<span class="sd">            if False `S, U, A, ca, ra` will be loaded sepratelly as `raw_S, raw_U, raw_A, raw_ca, raw_ra`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">substitute</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">loompy</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loom_filepath</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">layer</span><span class="p">[</span><span class="s2">&quot;spliced&quot;</span><span class="p">][:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">layer</span><span class="p">[</span><span class="s2">&quot;unspliced&quot;</span><span class="p">][:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">layer</span><span class="p">[</span><span class="s2">&quot;ambiguous&quot;</span><span class="p">][:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ca</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">col_attrs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ra</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">row_attrs</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">loompy</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loom_filepath</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raw_S</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">layer</span><span class="p">[</span><span class="s2">&quot;spliced&quot;</span><span class="p">][:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raw_U</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">layer</span><span class="p">[</span><span class="s2">&quot;unspliced&quot;</span><span class="p">][:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raw_A</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">layer</span><span class="p">[</span><span class="s2">&quot;ambiguous&quot;</span><span class="p">][:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raw_ca</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">col_attrs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raw_ra</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">row_attrs</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="scatter_viz"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.scatter_viz">[docs]</a><span class="k">def</span> <span class="nf">scatter_viz</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A wrapper of scatter plot that guarantees that every point is visible in a very crowded scatterplot</span>

<span class="sd">    Args</span>
<span class="sd">    ----</span>
<span class="sd">    x: np.ndarray</span>
<span class="sd">        x axis coordiantes</span>
<span class="sd">    y: np.ndarray</span>
<span class="sd">        y axis coordiantes</span>
<span class="sd">    args and kwargs:</span>
<span class="sd">        positional and keyword arguments as in matplotplib.pyplot.scatter</span>

<span class="sd">    Retruns</span>
<span class="sd">    -------</span>
<span class="sd">    Plots the graph and returns the axes object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ix_x_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)</span>
    <span class="n">ix_yx_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">ix_x_sort</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)</span>
    <span class="n">args_new</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kwargs_new</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">args_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="n">ix_x_sort</span><span class="p">][</span><span class="n">ix_yx_sort</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">karg</span><span class="p">,</span> <span class="n">varg</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">varg</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">kwargs_new</span><span class="p">[</span><span class="n">karg</span><span class="p">]</span> <span class="o">=</span> <span class="n">varg</span><span class="p">[</span><span class="n">ix_x_sort</span><span class="p">][</span><span class="n">ix_yx_sort</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs_new</span><span class="p">[</span><span class="n">karg</span><span class="p">]</span> <span class="o">=</span> <span class="n">varg</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">ix_x_sort</span><span class="p">][</span><span class="n">ix_yx_sort</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">ix_x_sort</span><span class="p">][</span><span class="n">ix_yx_sort</span><span class="p">],</span> <span class="o">*</span><span class="n">args_new</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_new</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="ixs_thatsort_a2b"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.ixs_thatsort_a2b">[docs]</a><span class="k">def</span> <span class="nf">ixs_thatsort_a2b</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">check_content</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="s2">&quot;This is super duper magic sauce to make the order of one list to be like another&quot;</span>
    <span class="k">if</span> <span class="n">check_content</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">f</span><span class="s2">&quot;The two arrays are not matching&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">a</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">b</span><span class="p">))]</span></div>

<span class="n">colors20</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Vega20b</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">))[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Vega20c</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">))[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]))</span>


<div class="viewcode-block" id="colormap_fun"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.colormap_fun">[docs]</a><span class="k">def</span> <span class="nf">colormap_fun</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">colors20</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">20</span><span class="p">)]</span></div>


<span class="nd">@jit</span><span class="p">(</span><span class="s2">&quot;float64[:](float64[:], int32[:], int32[:], float64[:])&quot;</span><span class="p">,</span> <span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_scale_to_match_median</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                           <span class="n">indptr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">genes_total</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="c1"># Helper function that operates directly on the .data array of a sparse matrix object</span>
    <span class="n">new_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># Loop through the columns</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">genes_total</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="c1"># Retrieve the values</span>
        <span class="n">non_zero_genes_total</span> <span class="o">=</span> <span class="n">genes_total</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]]</span>
        <span class="c1"># Find the normalization factor</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">non_zero_genes_total</span><span class="p">)</span> <span class="o">/</span> <span class="n">non_zero_genes_total</span><span class="p">)</span>
        <span class="n">new_data</span><span class="p">[</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">new_data</span>


<div class="viewcode-block" id="scale_to_match_median"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.scale_to_match_median">[docs]</a><span class="k">def</span> <span class="nf">scale_to_match_median</span><span class="p">(</span><span class="n">sparse_matrix</span><span class="p">:</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">,</span> <span class="n">genes_total</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Normalize contribution of different neighbor genes to match the median totals</span>
<span class="sd">    </span>
<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    sparse_matrix: sparse.csr_matrix</span>
<span class="sd">        weights matrix</span>
<span class="sd">    </span>
<span class="sd">    genes_total: sparse.csr_matrix shape=(sparse_matrix.shape[0])</span>
<span class="sd">        array of the total molecules detected for each gene</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knn_weights: sparse.csr_matrix</span>
<span class="sd">        sparse_matrix after the normalization</span>
<span class="sd">    </span>
<span class="sd">    # NOTE, since the use I made of this later I could have changed sparse_matrix in place</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">newdata</span> <span class="o">=</span> <span class="n">_scale_to_match_median</span><span class="p">(</span><span class="n">sparse_matrix</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">sparse_matrix</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">sparse_matrix</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">genes_total</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">((</span><span class="n">newdata</span><span class="p">,</span>
                              <span class="n">sparse_matrix</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span>
                              <span class="n">sparse_matrix</span><span class="o">.</span><span class="n">indptr</span><span class="p">),</span>
                             <span class="n">shape</span><span class="o">=</span><span class="n">sparse_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                             <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="gaussian_kernel"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.gaussian_kernel">[docs]</a><span class="k">def</span> <span class="nf">gaussian_kernel</span><span class="p">(</span><span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">mu</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute gaussian kernel&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Linnarsson Lab.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.9.5',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>